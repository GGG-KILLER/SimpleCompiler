// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// Modified by the Tsu (https://github.com/GGG-KILLER/Tsu) project for embedding into other projects.
// <auto-generated />

#nullable enable

namespace SimpleCompiler.IR
{
    using System.Collections;
    using System.Collections.Generic;

    /// <summary>
    /// A list of <see cref="global::SimpleCompiler.IR.IrNode"/>.
    /// </summary>
    public readonly partial struct IrList<TNode> : IReadOnlyList<TNode>, IEquatable<IrList<TNode>>
        where TNode : global::SimpleCompiler.IR.IrNode
    {
        private readonly global::SimpleCompiler.IR.IrNode? _node;

        internal IrList(global::SimpleCompiler.IR.IrNode? node)
        {
            _node = node;
        }

        /// <summary>
        /// Creates a singleton list of Ir nodes.
        /// </summary>/// <param name="node">The single element node.</param>
        public IrList(TNode? node)
            : this((global::SimpleCompiler.IR.IrNode?) node)
        {
        }

        /// <summary>
        /// Creates a list of Ir nodes.
        /// </summary>
        /// <param name="nodes">A sequence of element nodes.</param>
        public IrList(IEnumerable<TNode>? nodes)
            : this(CreateNode(nodes))
        {
        }

        private static global::SimpleCompiler.IR.IrNode? CreateNode(IEnumerable<TNode>? nodes)
        {
            if (nodes == null)
            {
                return null;
            }

            var builder = (nodes is ICollection<TNode> collection) ? new IrListBuilder<TNode>(collection.Count) : IrListBuilder<TNode>.Create();

            foreach (TNode node in nodes)
            {
                builder.Add(node);
            }

            return builder.ToList().Node;
        }

        internal global::SimpleCompiler.IR.IrNode? Node => _node;

        /// <summary>
        /// The number of nodes in the list.
        /// </summary>
        public int Count => _node == null ? 0 : (_node.IsList ? _node.SlotCount : 1);

        /// <summary>
        /// Gets the node at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the node to get or set.</param>
        /// <returns>The node at the specified index.</returns>
        public TNode this[int index]
        {
            get
            {
                if (_node != null)
                {
                    if (_node.IsList)
                    {
                        if (unchecked((uint) index < (uint) _node.SlotCount))
                        {
                            return (TNode) _node.GetNodeSlot(index)!;
                        }
                    }
                    else if (index == 0)
                    {
                        return (TNode) _node;
                    }
                }
                throw new ArgumentOutOfRangeException(nameof(index));
            }
        }

        internal global::SimpleCompiler.IR.IrNode? ItemInternal(int index)
        {
            if (_node?.IsList == true)
            {
                return _node.GetNodeSlot(index);
            }

            global::System.Diagnostics.Debug.Assert(index == 0);
            return _node;
        }

        /// <summary>
        /// Creates a new list with the specified node added at the end.
        /// </summary>
        /// <param name="node">The node to add.</param>
        public IrList<TNode> Add(TNode node) => Insert(Count, node);

        /// <summary>
        /// Creates a new list with the specified nodes added at the end.
        /// </summary>
        /// <param name="nodes">The nodes to add.</param>
        public IrList<TNode> AddRange(IEnumerable<TNode> nodes) =>
            InsertRange(Count, nodes);

        /// <summary>
        /// Creates a new list with the specified node inserted at the index.
        /// </summary>
        /// <param name="index">The index to insert at.</param>
        /// <param name="node">The node to insert.</param>
        public IrList<TNode> Insert(int index, TNode node)
        {
            if (node is null) throw new ArgumentNullException(nameof(node));
            return InsertRange(index, new[] { node });
        }

        /// <summary>
        /// Creates a new list with the specified nodes inserted at the index.
        /// </summary>
        /// <param name="index">The index to insert at.</param>
        /// <param name="nodes">The nodes to insert.</param>
        public IrList<TNode> InsertRange(int index, IEnumerable<TNode> nodes)
        {
            if (index < 0 || index > Count)
            {
                throw new ArgumentOutOfRangeException(nameof(index));
            }

            if (nodes is null) throw new ArgumentNullException(nameof(nodes));
            var list = this.ToList();
            list.InsertRange(index, nodes);

            if (list.Count == 0)
            {
                return this;
            }
            else
            {
                return CreateList(list);
            }
        }

        /// <summary>
        /// Creates a new list with the element at specified index removed.
        /// </summary>
        /// <param name="index">The index of the element to remove.</param>
        public IrList<TNode> RemoveAt(int index)
        {
            if (index < 0 || index > Count)
            {
                throw new ArgumentOutOfRangeException(nameof(index));
            }

            return Remove(this[index]);
        }

        /// <summary>
        /// Creates a new list with the element removed.
        /// </summary>
        /// <param name="node">The element to remove.</param>
        public IrList<TNode> Remove(TNode node) =>
            CreateList(this.Where(x => x != node).ToList());

        /// <summary>
        /// Creates a new list with the specified element replaced with the new node.
        /// </summary>
        /// <param name="nodeInList">The element to replace.</param>
        /// <param name="newNode">The new node.</param>
        public IrList<TNode> Replace(TNode nodeInList, TNode newNode) =>
            ReplaceRange(nodeInList, new[] { newNode });

        /// <summary>
        /// Creates a new list with the specified element replaced with new nodes.
        /// </summary>
        /// <param name="nodeInList">The element to replace.</param>
        /// <param name="newNodes">The new nodes.</param>
        public IrList<TNode> ReplaceRange(TNode nodeInList, IEnumerable<TNode> newNodes)
        {
            if (nodeInList is null) throw new ArgumentNullException(nameof(nodeInList));
            if (newNodes is null) throw new ArgumentNullException(nameof(newNodes));
            var index = IndexOf(nodeInList);
            if (index >= 0 && index < Count)
            {
                var list = this.ToList();
                list.RemoveAt(index);
                list.InsertRange(index, newNodes);
                return CreateList(list);
            }
            else
            {
                throw new ArgumentException($"'{nameof(nodeInList)}' was not found in the list.", nameof(nodeInList));
            }
        }

        private static IrList<TNode> CreateList(List<TNode> items)
        {
            if (items.Count == 0)
            {
                return default;
            }

            var newGreen = global::SimpleCompiler.IR.Internal.IrNode.CreateList(items, static n => n.Green);
            return new IrList<TNode>(newGreen!.CreateRed());
        }

        /// <summary>
        /// The first node in the list.
        /// </summary>
        public TNode First() => this[0];

        /// <summary>
        /// The first node in the list or default if the list is empty.
        /// </summary>
        public TNode? FirstOrDefault()
        {
            if (Any())
            {
                return this[0];
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// The last node in the list.
        /// </summary>
        public TNode Last() => this[Count - 1];

        /// <summary>
        /// The last node in the list or default if the list is empty.
        /// </summary>
        public TNode? LastOrDefault()
        {
            if (Any())
            {
                return this[Count - 1];
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// True if the list has at least one node.
        /// </summary>
        public bool Any()
        {
            global::System.Diagnostics.Debug.Assert(_node == null || Count != 0);
            return _node != null;
        }

        internal bool All(Func<TNode, bool> predicate)
        {
            foreach (var item in this)
            {
                if (!predicate(item))
                {
                    return false;
                }
            }

            return true;
        }

#if DEBUG
        [Obsolete("For debugging only", true)]
        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("CodeQuality", "IDE0051:Remove unused private members", Justification = "For debugging only")]
        private TNode[] Nodes => this.ToArray();
#endif

        /// <summary>
        /// Gets the enumerator for this list.
        /// </summary>
#pragma warning disable RS0041 // uses oblivious reference types
        public Enumerator GetEnumerator() => new(this);

        IEnumerator<TNode> IEnumerable<TNode>.GetEnumerator() => new EnumeratorImpl(this);

        IEnumerator IEnumerable.GetEnumerator() => new EnumeratorImpl(this);

        /// <summary>
        /// Checks whether two lists are equal.
        /// Does a reference check instead of structural.
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        public static bool operator ==(IrList<TNode> left, IrList<TNode> right) =>
            left._node == right._node;

        /// <summary>
        /// Checks whether two lists are not equal.
        /// Does a reference check instead of structural.
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        public static bool operator !=(IrList<TNode> left, IrList<TNode> right) =>
            left._node != right._node;

        /// <inheritdoc/>
        public bool Equals(IrList<TNode> other) => _node == other._node;

        /// <inheritdoc/>
        public override bool Equals(object? obj) =>
            obj is IrList<TNode> list && Equals(list);

        /// <inheritdoc/>
        public override int GetHashCode() => _node?.GetHashCode() ?? 0;

        /// <summary>
        /// Converts an opaquely typed node list into a typed node list.
        /// </summary>
        /// <param name="nodes"></param>
        public static implicit operator IrList<TNode>(IrList<global::SimpleCompiler.IR.IrNode> nodes) =>
            new(nodes._node);

        /// <summary>
        /// Converts a typed node list into an opaquely typed node list.
        /// </summary>
        /// <param name="nodes"></param>
        public static implicit operator IrList<global::SimpleCompiler.IR.IrNode>(IrList<TNode> nodes) =>
            new(nodes.Node);

        /// <summary>
        /// The index of the node in this list, or -1 if the node is not in the list.
        /// </summary>
        public int IndexOf(TNode node)
        {
            var index = 0;
            foreach (var child in this)
            {
                if (Equals(child, node))
                {
                    return index;
                }

                index++;
            }

            return -1;
        }

        /// <summary>
        /// Returns the index of the first node in this list that passes the provided predicate.
        /// </summary>
        /// <param name="predicate"></param>
        /// <returns>-1 if not found.</returns>
        public int IndexOf(Func<TNode, bool> predicate)
        {
            var index = 0;
            foreach (var child in this)
            {
                if (predicate(child))
                {
                    return index;
                }

                index++;
            }

            return -1;
        }

        internal int IndexOf(global::SimpleCompiler.IR.IrKind kind)
        {
            var index = 0;
            foreach (var child in this)
            {
                if (child.Kind == kind)
                {
                    return index;
                }

                index++;
            }

            return -1;
        }

        /// <summary>
        /// Returns the index of the last item that is equal to the provided node in this list.
        /// </summary>
        /// <param name="node"></param>
        /// <returns>-1 if not found.</returns>
        public int LastIndexOf(TNode node)
        {
            for (int i = Count - 1; i >= 0; i--)
            {
                if (Equals(this[i], node))
                {
                    return i;
                }
            }

            return -1;
        }

        /// <summary>
        /// Returns the index of the last node in this list that passes the provided predicate.
        /// </summary>
        /// <param name="predicate"></param>
        /// <returns></returns>
        public int LastIndexOf(Func<TNode, bool> predicate)
        {
            for (int i = Count - 1; i >= 0; i--)
            {
                if (predicate(this[i]))
                {
                    return i;
                }
            }

            return -1;
        }
    }
}
