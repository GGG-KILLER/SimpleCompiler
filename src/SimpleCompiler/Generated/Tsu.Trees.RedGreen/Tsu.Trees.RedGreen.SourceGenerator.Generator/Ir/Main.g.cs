// <auto-generated />

#nullable enable

using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using SimpleCompiler.IR.Internal;

namespace SimpleCompiler.IR
{

    public partial class IrVisitor
    {
        public virtual void Visit(global::SimpleCompiler.IR.IrNode? node)
        {
            if (node != null)
            {
                node.Accept(this);
            }
        }
        public virtual void VisitIrNone(global::SimpleCompiler.IR.IrNone node) => this.DefaultVisit(node);
        public virtual void VisitBinaryOperationExpression(global::SimpleCompiler.IR.BinaryOperationExpression node) => this.DefaultVisit(node);
        public virtual void VisitConstantExpression(global::SimpleCompiler.IR.ConstantExpression node) => this.DefaultVisit(node);
        public virtual void VisitDiscardExpression(global::SimpleCompiler.IR.DiscardExpression node) => this.DefaultVisit(node);
        public virtual void VisitFunctionCallExpression(global::SimpleCompiler.IR.FunctionCallExpression node) => this.DefaultVisit(node);
        public virtual void VisitUnaryOperationExpression(global::SimpleCompiler.IR.UnaryOperationExpression node) => this.DefaultVisit(node);
        public virtual void VisitVariableExpression(global::SimpleCompiler.IR.VariableExpression node) => this.DefaultVisit(node);
        public virtual void VisitAssignmentStatement(global::SimpleCompiler.IR.AssignmentStatement node) => this.DefaultVisit(node);
        public virtual void VisitEmptyStatement(global::SimpleCompiler.IR.EmptyStatement node) => this.DefaultVisit(node);
        public virtual void VisitExpressionStatement(global::SimpleCompiler.IR.ExpressionStatement node) => this.DefaultVisit(node);
        public virtual void VisitStatementList(global::SimpleCompiler.IR.StatementList node) => this.DefaultVisit(node);
        protected virtual void DefaultVisit(global::SimpleCompiler.IR.IrNode node) { }
    }

    public partial class IrVisitor<TResult>
    {
        public virtual TResult? Visit(global::SimpleCompiler.IR.IrNode? node) => node == null ? default : node.Accept(this
        );
        public virtual TResult? VisitIrNone(global::SimpleCompiler.IR.IrNone node) => this.DefaultVisit(node);
        public virtual TResult? VisitBinaryOperationExpression(global::SimpleCompiler.IR.BinaryOperationExpression node) => this.DefaultVisit(node);
        public virtual TResult? VisitConstantExpression(global::SimpleCompiler.IR.ConstantExpression node) => this.DefaultVisit(node);
        public virtual TResult? VisitDiscardExpression(global::SimpleCompiler.IR.DiscardExpression node) => this.DefaultVisit(node);
        public virtual TResult? VisitFunctionCallExpression(global::SimpleCompiler.IR.FunctionCallExpression node) => this.DefaultVisit(node);
        public virtual TResult? VisitUnaryOperationExpression(global::SimpleCompiler.IR.UnaryOperationExpression node) => this.DefaultVisit(node);
        public virtual TResult? VisitVariableExpression(global::SimpleCompiler.IR.VariableExpression node) => this.DefaultVisit(node);
        public virtual TResult? VisitAssignmentStatement(global::SimpleCompiler.IR.AssignmentStatement node) => this.DefaultVisit(node);
        public virtual TResult? VisitEmptyStatement(global::SimpleCompiler.IR.EmptyStatement node) => this.DefaultVisit(node);
        public virtual TResult? VisitExpressionStatement(global::SimpleCompiler.IR.ExpressionStatement node) => this.DefaultVisit(node);
        public virtual TResult? VisitStatementList(global::SimpleCompiler.IR.StatementList node) => this.DefaultVisit(node);
        protected virtual TResult? DefaultVisit(global::SimpleCompiler.IR.IrNode node) => default;
    }

    public partial class IrVisitor<T1, TResult>
    {
        public virtual TResult? Visit(global::SimpleCompiler.IR.IrNode? node, T1 arg1) => node == null ? default : node.Accept(this
        , arg1);
        public virtual TResult? VisitIrNone(global::SimpleCompiler.IR.IrNone node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitBinaryOperationExpression(global::SimpleCompiler.IR.BinaryOperationExpression node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitConstantExpression(global::SimpleCompiler.IR.ConstantExpression node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitDiscardExpression(global::SimpleCompiler.IR.DiscardExpression node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitFunctionCallExpression(global::SimpleCompiler.IR.FunctionCallExpression node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitUnaryOperationExpression(global::SimpleCompiler.IR.UnaryOperationExpression node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitVariableExpression(global::SimpleCompiler.IR.VariableExpression node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitAssignmentStatement(global::SimpleCompiler.IR.AssignmentStatement node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitEmptyStatement(global::SimpleCompiler.IR.EmptyStatement node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitExpressionStatement(global::SimpleCompiler.IR.ExpressionStatement node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitStatementList(global::SimpleCompiler.IR.StatementList node, T1 arg1) => this.DefaultVisit(node, arg1);
        protected virtual TResult? DefaultVisit(global::SimpleCompiler.IR.IrNode node, T1 arg1) => default;
    }

    public partial class IrVisitor<T1, T2, TResult>
    {
        public virtual TResult? Visit(global::SimpleCompiler.IR.IrNode? node, T1 arg1, T2 arg2) => node == null ? default : node.Accept(this
        , arg1, arg2);
        public virtual TResult? VisitIrNone(global::SimpleCompiler.IR.IrNone node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitBinaryOperationExpression(global::SimpleCompiler.IR.BinaryOperationExpression node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitConstantExpression(global::SimpleCompiler.IR.ConstantExpression node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitDiscardExpression(global::SimpleCompiler.IR.DiscardExpression node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitFunctionCallExpression(global::SimpleCompiler.IR.FunctionCallExpression node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitUnaryOperationExpression(global::SimpleCompiler.IR.UnaryOperationExpression node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitVariableExpression(global::SimpleCompiler.IR.VariableExpression node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitAssignmentStatement(global::SimpleCompiler.IR.AssignmentStatement node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitEmptyStatement(global::SimpleCompiler.IR.EmptyStatement node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitExpressionStatement(global::SimpleCompiler.IR.ExpressionStatement node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitStatementList(global::SimpleCompiler.IR.StatementList node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        protected virtual TResult? DefaultVisit(global::SimpleCompiler.IR.IrNode node, T1 arg1, T2 arg2) => default;
    }

    public partial class IrVisitor<T1, T2, T3, TResult>
    {
        public virtual TResult? Visit(global::SimpleCompiler.IR.IrNode? node, T1 arg1, T2 arg2, T3 arg3) => node == null ? default : node.Accept(this
        , arg1, arg2, arg3);
        public virtual TResult? VisitIrNone(global::SimpleCompiler.IR.IrNone node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitBinaryOperationExpression(global::SimpleCompiler.IR.BinaryOperationExpression node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitConstantExpression(global::SimpleCompiler.IR.ConstantExpression node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitDiscardExpression(global::SimpleCompiler.IR.DiscardExpression node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitFunctionCallExpression(global::SimpleCompiler.IR.FunctionCallExpression node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitUnaryOperationExpression(global::SimpleCompiler.IR.UnaryOperationExpression node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitVariableExpression(global::SimpleCompiler.IR.VariableExpression node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitAssignmentStatement(global::SimpleCompiler.IR.AssignmentStatement node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitEmptyStatement(global::SimpleCompiler.IR.EmptyStatement node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitExpressionStatement(global::SimpleCompiler.IR.ExpressionStatement node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitStatementList(global::SimpleCompiler.IR.StatementList node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        protected virtual TResult? DefaultVisit(global::SimpleCompiler.IR.IrNode node, T1 arg1, T2 arg2, T3 arg3) => default;
    }



    public partial class IrRewriter : global::SimpleCompiler.IR.IrVisitor<global::SimpleCompiler.IR.IrNode>
    {
        public global::SimpleCompiler.IR.IrList<TNode> VisitList<TNode>(global::SimpleCompiler.IR.IrList<TNode> list) where TNode : global::SimpleCompiler.IR.IrNode
        {
            global::SimpleCompiler.IR.IrListBuilder? alternate = null;
            for (int i = 0, n = list.Count; i < n; i++)
            {
                var item = list[i];
                var visited = Visit(item);
                if (item != visited && alternate == null)
                {
                    alternate = new global::SimpleCompiler.IR.IrListBuilder(n);
                    alternate.AddRange(list, 0, i);
                }

                if (alternate != null && visited != null && visited.Kind != global::SimpleCompiler.IR.IrKind.None)
                {
                    alternate.Add(visited);
                }
            }

            if (alternate != null)
            {
                return alternate.ToList();
            }

            return list;
        }

        public override global::SimpleCompiler.IR.IrNode VisitIrNone(global::SimpleCompiler.IR.IrNone node) =>
            node.Update(node.OriginalNode);
        public override global::SimpleCompiler.IR.IrNode VisitBinaryOperationExpression(global::SimpleCompiler.IR.BinaryOperationExpression node) =>
            node.Update(node.OriginalNode, node.ResultKind, node.BinaryOperationKind, (global::SimpleCompiler.IR.Expression?)Visit(node.Left) ?? throw new global::System.InvalidOperationException("Left cannot be null."), (global::SimpleCompiler.IR.Expression?)Visit(node.Right) ?? throw new global::System.InvalidOperationException("Right cannot be null."));
        public override global::SimpleCompiler.IR.IrNode VisitConstantExpression(global::SimpleCompiler.IR.ConstantExpression node) =>
            node.Update(node.OriginalNode, node.ResultKind, node.ConstantKind, node.Value);
        public override global::SimpleCompiler.IR.IrNode VisitDiscardExpression(global::SimpleCompiler.IR.DiscardExpression node) =>
            node.Update(node.OriginalNode, node.ResultKind);
        public override global::SimpleCompiler.IR.IrNode VisitFunctionCallExpression(global::SimpleCompiler.IR.FunctionCallExpression node) =>
            node.Update(node.OriginalNode, node.ResultKind, (global::SimpleCompiler.IR.Expression?)Visit(node.Callee) ?? throw new global::System.InvalidOperationException("Callee cannot be null."), VisitList(node.Arguments));
        public override global::SimpleCompiler.IR.IrNode VisitUnaryOperationExpression(global::SimpleCompiler.IR.UnaryOperationExpression node) =>
            node.Update(node.OriginalNode, node.ResultKind, node.UnaryOperationKind, (global::SimpleCompiler.IR.Expression?)Visit(node.Operand) ?? throw new global::System.InvalidOperationException("Operand cannot be null."));
        public override global::SimpleCompiler.IR.IrNode VisitVariableExpression(global::SimpleCompiler.IR.VariableExpression node) =>
            node.Update(node.OriginalNode, node.ResultKind, node.VariableInfo);
        public override global::SimpleCompiler.IR.IrNode VisitAssignmentStatement(global::SimpleCompiler.IR.AssignmentStatement node) =>
            node.Update(node.OriginalNode, VisitList(node.Assignees), VisitList(node.Values));
        public override global::SimpleCompiler.IR.IrNode VisitEmptyStatement(global::SimpleCompiler.IR.EmptyStatement node) =>
            node.Update(node.OriginalNode);
        public override global::SimpleCompiler.IR.IrNode VisitExpressionStatement(global::SimpleCompiler.IR.ExpressionStatement node) =>
            node.Update(node.OriginalNode, (global::SimpleCompiler.IR.Expression?)Visit(node.Expression) ?? throw new global::System.InvalidOperationException("Expression cannot be null."));
        public override global::SimpleCompiler.IR.IrNode VisitStatementList(global::SimpleCompiler.IR.StatementList node) =>
            node.Update(node.OriginalNode, VisitList(node.Statements), node.ScopeInfo);
    }
    public static partial class IrFactory
    {
        public static global::SimpleCompiler.IR.IrNone IrNone() =>
            (global::SimpleCompiler.IR.IrNone) global::SimpleCompiler.IR.Internal.IrFactory.IrNone().CreateRed();

        public static global::SimpleCompiler.IR.IrNone IrNone(global::Loretta.CodeAnalysis.SyntaxReference? originalNode) =>
            (global::SimpleCompiler.IR.IrNone) global::SimpleCompiler.IR.Internal.IrFactory.IrNone(originalNode).CreateRed();

        public static global::SimpleCompiler.IR.BinaryOperationExpression BinaryOperationExpression(global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.BinaryOperationKind binaryOperationKind, global::SimpleCompiler.IR.Expression left, global::SimpleCompiler.IR.Expression right) =>
            (global::SimpleCompiler.IR.BinaryOperationExpression) global::SimpleCompiler.IR.Internal.IrFactory.BinaryOperationExpression(resultKind, binaryOperationKind, (global::SimpleCompiler.IR.Internal.Expression)left.Green, (global::SimpleCompiler.IR.Internal.Expression)right.Green).CreateRed();

        public static global::SimpleCompiler.IR.BinaryOperationExpression BinaryOperationExpression(global::Loretta.CodeAnalysis.SyntaxReference? originalNode, global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.BinaryOperationKind binaryOperationKind, global::SimpleCompiler.IR.Expression left, global::SimpleCompiler.IR.Expression right) =>
            (global::SimpleCompiler.IR.BinaryOperationExpression) global::SimpleCompiler.IR.Internal.IrFactory.BinaryOperationExpression(originalNode, resultKind, binaryOperationKind, (global::SimpleCompiler.IR.Internal.Expression)left.Green, (global::SimpleCompiler.IR.Internal.Expression)right.Green).CreateRed();

        public static global::SimpleCompiler.IR.ConstantExpression ConstantExpression(global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.ConstantKind constantKind) =>
            (global::SimpleCompiler.IR.ConstantExpression) global::SimpleCompiler.IR.Internal.IrFactory.ConstantExpression(resultKind, constantKind).CreateRed();

        public static global::SimpleCompiler.IR.ConstantExpression ConstantExpression(global::Loretta.CodeAnalysis.SyntaxReference? originalNode, global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.ConstantKind constantKind, object? value) =>
            (global::SimpleCompiler.IR.ConstantExpression) global::SimpleCompiler.IR.Internal.IrFactory.ConstantExpression(originalNode, resultKind, constantKind, value).CreateRed();

        public static global::SimpleCompiler.IR.DiscardExpression DiscardExpression(global::SimpleCompiler.IR.ResultKind resultKind) =>
            (global::SimpleCompiler.IR.DiscardExpression) global::SimpleCompiler.IR.Internal.IrFactory.DiscardExpression(resultKind).CreateRed();

        public static global::SimpleCompiler.IR.DiscardExpression DiscardExpression(global::Loretta.CodeAnalysis.SyntaxReference? originalNode, global::SimpleCompiler.IR.ResultKind resultKind) =>
            (global::SimpleCompiler.IR.DiscardExpression) global::SimpleCompiler.IR.Internal.IrFactory.DiscardExpression(originalNode, resultKind).CreateRed();

        public static global::SimpleCompiler.IR.FunctionCallExpression FunctionCallExpression(global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.Expression callee) =>
            (global::SimpleCompiler.IR.FunctionCallExpression) global::SimpleCompiler.IR.Internal.IrFactory.FunctionCallExpression(resultKind, (global::SimpleCompiler.IR.Internal.Expression)callee.Green).CreateRed();

        public static global::SimpleCompiler.IR.FunctionCallExpression FunctionCallExpression(global::Loretta.CodeAnalysis.SyntaxReference? originalNode, global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.Expression callee, global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Expression> arguments) =>
            (global::SimpleCompiler.IR.FunctionCallExpression) global::SimpleCompiler.IR.Internal.IrFactory.FunctionCallExpression(originalNode, resultKind, (global::SimpleCompiler.IR.Internal.Expression)callee.Green, arguments.Node.ToIrList<global::SimpleCompiler.IR.Internal.Expression>()).CreateRed();

        public static global::SimpleCompiler.IR.UnaryOperationExpression UnaryOperationExpression(global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.UnaryOperationKind unaryOperationKind, global::SimpleCompiler.IR.Expression operand) =>
            (global::SimpleCompiler.IR.UnaryOperationExpression) global::SimpleCompiler.IR.Internal.IrFactory.UnaryOperationExpression(resultKind, unaryOperationKind, (global::SimpleCompiler.IR.Internal.Expression)operand.Green).CreateRed();

        public static global::SimpleCompiler.IR.UnaryOperationExpression UnaryOperationExpression(global::Loretta.CodeAnalysis.SyntaxReference? originalNode, global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.UnaryOperationKind unaryOperationKind, global::SimpleCompiler.IR.Expression operand) =>
            (global::SimpleCompiler.IR.UnaryOperationExpression) global::SimpleCompiler.IR.Internal.IrFactory.UnaryOperationExpression(originalNode, resultKind, unaryOperationKind, (global::SimpleCompiler.IR.Internal.Expression)operand.Green).CreateRed();

        public static global::SimpleCompiler.IR.VariableExpression VariableExpression(global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.VariableInfo variableInfo) =>
            (global::SimpleCompiler.IR.VariableExpression) global::SimpleCompiler.IR.Internal.IrFactory.VariableExpression(resultKind, variableInfo).CreateRed();

        public static global::SimpleCompiler.IR.VariableExpression VariableExpression(global::Loretta.CodeAnalysis.SyntaxReference? originalNode, global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.VariableInfo variableInfo) =>
            (global::SimpleCompiler.IR.VariableExpression) global::SimpleCompiler.IR.Internal.IrFactory.VariableExpression(originalNode, resultKind, variableInfo).CreateRed();

        public static global::SimpleCompiler.IR.AssignmentStatement AssignmentStatement() =>
            (global::SimpleCompiler.IR.AssignmentStatement) global::SimpleCompiler.IR.Internal.IrFactory.AssignmentStatement().CreateRed();

        public static global::SimpleCompiler.IR.AssignmentStatement AssignmentStatement(global::Loretta.CodeAnalysis.SyntaxReference? originalNode, global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Expression> assignees, global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Expression> values) =>
            (global::SimpleCompiler.IR.AssignmentStatement) global::SimpleCompiler.IR.Internal.IrFactory.AssignmentStatement(originalNode, assignees.Node.ToIrList<global::SimpleCompiler.IR.Internal.Expression>(), values.Node.ToIrList<global::SimpleCompiler.IR.Internal.Expression>()).CreateRed();

        public static global::SimpleCompiler.IR.EmptyStatement EmptyStatement() =>
            (global::SimpleCompiler.IR.EmptyStatement) global::SimpleCompiler.IR.Internal.IrFactory.EmptyStatement().CreateRed();

        public static global::SimpleCompiler.IR.EmptyStatement EmptyStatement(global::Loretta.CodeAnalysis.SyntaxReference? originalNode) =>
            (global::SimpleCompiler.IR.EmptyStatement) global::SimpleCompiler.IR.Internal.IrFactory.EmptyStatement(originalNode).CreateRed();

        public static global::SimpleCompiler.IR.ExpressionStatement ExpressionStatement(global::SimpleCompiler.IR.Expression expression) =>
            (global::SimpleCompiler.IR.ExpressionStatement) global::SimpleCompiler.IR.Internal.IrFactory.ExpressionStatement((global::SimpleCompiler.IR.Internal.Expression)expression.Green).CreateRed();

        public static global::SimpleCompiler.IR.ExpressionStatement ExpressionStatement(global::Loretta.CodeAnalysis.SyntaxReference? originalNode, global::SimpleCompiler.IR.Expression expression) =>
            (global::SimpleCompiler.IR.ExpressionStatement) global::SimpleCompiler.IR.Internal.IrFactory.ExpressionStatement(originalNode, (global::SimpleCompiler.IR.Internal.Expression)expression.Green).CreateRed();

        public static global::SimpleCompiler.IR.StatementList StatementList() =>
            (global::SimpleCompiler.IR.StatementList) global::SimpleCompiler.IR.Internal.IrFactory.StatementList().CreateRed();

        public static global::SimpleCompiler.IR.StatementList StatementList(global::Loretta.CodeAnalysis.SyntaxReference? originalNode, global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Statement> statements, global::SimpleCompiler.IR.ScopeInfo? scopeInfo) =>
            (global::SimpleCompiler.IR.StatementList) global::SimpleCompiler.IR.Internal.IrFactory.StatementList(originalNode, statements.Node.ToIrList<global::SimpleCompiler.IR.Internal.Statement>(), scopeInfo).CreateRed();
    }
}

