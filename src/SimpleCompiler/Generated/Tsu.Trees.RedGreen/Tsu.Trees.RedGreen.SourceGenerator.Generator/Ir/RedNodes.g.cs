// <auto-generated />

#nullable enable


namespace SimpleCompiler.IR
{
    public abstract partial class Statement : global::SimpleCompiler.IR.IrNode
    {

        internal Statement(global::SimpleCompiler.IR.Internal.IrNode green, global::SimpleCompiler.IR.IrNode? parent)
            : base(green, parent)
        {
        }







    }
    public partial class StatementList : global::SimpleCompiler.IR.Statement
    {
        private global::SimpleCompiler.IR.IrNode? _statements;

        internal StatementList(global::SimpleCompiler.IR.Internal.IrNode green, global::SimpleCompiler.IR.IrNode? parent)
            : base(green, parent)
        {
        }

        public override  global::Loretta.CodeAnalysis.SyntaxReference? OriginalNode => ((global::SimpleCompiler.IR.Internal.StatementList)this.Green).OriginalNode;
        public  global::SimpleCompiler.IR.ScopeInfo? ScopeInfo => ((global::SimpleCompiler.IR.Internal.StatementList)this.Green).ScopeInfo;
            public global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Statement> Statements => new global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Statement>(GetRed(ref this._statements, 0));

        internal override global::SimpleCompiler.IR.IrNode? GetNodeSlot(int index) =>
                index == 0 ? GetRed(ref this._statements, 0) : null;

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.IR.IrVisitor visitor) =>
            visitor.VisitStatementList(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.IR.IrVisitor<TResult> visitor) =>
            visitor.VisitStatementList(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitStatementList(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitStatementList(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitStatementList(this, arg1, arg2, arg3);

        public global::SimpleCompiler.IR.StatementList Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Statement> statements,
            global::SimpleCompiler.IR.ScopeInfo? scopeInfo
        )
        {
            if (
                this.OriginalNode != originalNode
                || this.Statements != statements
                || this.ScopeInfo != scopeInfo
            )
            {
                return global::SimpleCompiler.IR.IrFactory.StatementList(
                    originalNode,
                    statements,
                    scopeInfo
                );
            }

            return this;
        }

        public global::SimpleCompiler.IR.StatementList WithOriginalNode(global::Loretta.CodeAnalysis.SyntaxReference? originalNode) =>
            this.Update(
                originalNode,
                this.Statements,
                this.ScopeInfo
            );
        public global::SimpleCompiler.IR.StatementList WithStatements(global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Statement> statements) =>
            this.Update(
                this.OriginalNode,
                statements,
                this.ScopeInfo
            );
        public global::SimpleCompiler.IR.StatementList WithScopeInfo(global::SimpleCompiler.IR.ScopeInfo? scopeInfo) =>
            this.Update(
                this.OriginalNode,
                this.Statements,
                scopeInfo
            );
    }
    public partial class ExpressionStatement : global::SimpleCompiler.IR.Statement
    {
        private global::SimpleCompiler.IR.Expression? _expression;

        internal ExpressionStatement(global::SimpleCompiler.IR.Internal.IrNode green, global::SimpleCompiler.IR.IrNode? parent)
            : base(green, parent)
        {
        }

        public override  global::Loretta.CodeAnalysis.SyntaxReference? OriginalNode => ((global::SimpleCompiler.IR.Internal.ExpressionStatement)this.Green).OriginalNode;
        public global::SimpleCompiler.IR.Expression Expression => GetRed(ref this._expression, 0)!;

        internal override global::SimpleCompiler.IR.IrNode? GetNodeSlot(int index) =>
                index == 0 ? GetRed(ref this._expression, 0)! : null;

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.IR.IrVisitor visitor) =>
            visitor.VisitExpressionStatement(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.IR.IrVisitor<TResult> visitor) =>
            visitor.VisitExpressionStatement(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitExpressionStatement(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitExpressionStatement(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitExpressionStatement(this, arg1, arg2, arg3);

        public global::SimpleCompiler.IR.ExpressionStatement Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.IR.Expression expression
        )
        {
            if (
                this.OriginalNode != originalNode
                || this.Expression != expression
            )
            {
                return global::SimpleCompiler.IR.IrFactory.ExpressionStatement(
                    originalNode,
                    expression
                );
            }

            return this;
        }

        public global::SimpleCompiler.IR.ExpressionStatement WithOriginalNode(global::Loretta.CodeAnalysis.SyntaxReference? originalNode) =>
            this.Update(
                originalNode,
                this.Expression
            );
        public global::SimpleCompiler.IR.ExpressionStatement WithExpression(global::SimpleCompiler.IR.Expression expression) =>
            this.Update(
                this.OriginalNode,
                expression
            );
    }
    public partial class EmptyStatement : global::SimpleCompiler.IR.Statement
    {

        internal EmptyStatement(global::SimpleCompiler.IR.Internal.IrNode green, global::SimpleCompiler.IR.IrNode? parent)
            : base(green, parent)
        {
        }

        public override  global::Loretta.CodeAnalysis.SyntaxReference? OriginalNode => ((global::SimpleCompiler.IR.Internal.EmptyStatement)this.Green).OriginalNode;

        internal override global::SimpleCompiler.IR.IrNode? GetNodeSlot(int index) =>
                null;

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.IR.IrVisitor visitor) =>
            visitor.VisitEmptyStatement(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.IR.IrVisitor<TResult> visitor) =>
            visitor.VisitEmptyStatement(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitEmptyStatement(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitEmptyStatement(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitEmptyStatement(this, arg1, arg2, arg3);

        public global::SimpleCompiler.IR.EmptyStatement Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode
        )
        {
            if (
                this.OriginalNode != originalNode
            )
            {
                return global::SimpleCompiler.IR.IrFactory.EmptyStatement(
                    originalNode
                );
            }

            return this;
        }

        public global::SimpleCompiler.IR.EmptyStatement WithOriginalNode(global::Loretta.CodeAnalysis.SyntaxReference? originalNode) =>
            this.Update(
                originalNode
            );
    }
    public partial class AssignmentStatement : global::SimpleCompiler.IR.Statement
    {
        private global::SimpleCompiler.IR.IrNode? _assignees;
        private global::SimpleCompiler.IR.IrNode? _values;

        internal AssignmentStatement(global::SimpleCompiler.IR.Internal.IrNode green, global::SimpleCompiler.IR.IrNode? parent)
            : base(green, parent)
        {
        }

        public override  global::Loretta.CodeAnalysis.SyntaxReference? OriginalNode => ((global::SimpleCompiler.IR.Internal.AssignmentStatement)this.Green).OriginalNode;
            public global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Expression> Assignees => new global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Expression>(GetRed(ref this._assignees, 0));
            public global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Expression> Values => new global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Expression>(GetRed(ref this._values, 1));

        internal override global::SimpleCompiler.IR.IrNode? GetNodeSlot(int index) =>
                index switch
                {
                    0 => GetRed(ref this._assignees, 0),
                    1 => GetRed(ref this._values, 1),
                    _ => null
                };

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.IR.IrVisitor visitor) =>
            visitor.VisitAssignmentStatement(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.IR.IrVisitor<TResult> visitor) =>
            visitor.VisitAssignmentStatement(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitAssignmentStatement(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitAssignmentStatement(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitAssignmentStatement(this, arg1, arg2, arg3);

        public global::SimpleCompiler.IR.AssignmentStatement Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Expression> assignees,
            global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Expression> values
        )
        {
            if (
                this.OriginalNode != originalNode
                || this.Assignees != assignees
                || this.Values != values
            )
            {
                return global::SimpleCompiler.IR.IrFactory.AssignmentStatement(
                    originalNode,
                    assignees,
                    values
                );
            }

            return this;
        }

        public global::SimpleCompiler.IR.AssignmentStatement WithOriginalNode(global::Loretta.CodeAnalysis.SyntaxReference? originalNode) =>
            this.Update(
                originalNode,
                this.Assignees,
                this.Values
            );
        public global::SimpleCompiler.IR.AssignmentStatement WithAssignees(global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Expression> assignees) =>
            this.Update(
                this.OriginalNode,
                assignees,
                this.Values
            );
        public global::SimpleCompiler.IR.AssignmentStatement WithValues(global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Expression> values) =>
            this.Update(
                this.OriginalNode,
                this.Assignees,
                values
            );
    }
    public abstract partial class Expression : global::SimpleCompiler.IR.IrNode
    {

        internal Expression(global::SimpleCompiler.IR.Internal.IrNode green, global::SimpleCompiler.IR.IrNode? parent)
            : base(green, parent)
        {
        }

        public abstract global::SimpleCompiler.IR.ResultKind ResultKind { get; }






    }
    public partial class VariableExpression : global::SimpleCompiler.IR.Expression
    {

        internal VariableExpression(global::SimpleCompiler.IR.Internal.IrNode green, global::SimpleCompiler.IR.IrNode? parent)
            : base(green, parent)
        {
        }

        public override  global::Loretta.CodeAnalysis.SyntaxReference? OriginalNode => ((global::SimpleCompiler.IR.Internal.VariableExpression)this.Green).OriginalNode;
        public override  global::SimpleCompiler.IR.ResultKind ResultKind => ((global::SimpleCompiler.IR.Internal.VariableExpression)this.Green).ResultKind;
        public  global::SimpleCompiler.IR.VariableInfo VariableInfo => ((global::SimpleCompiler.IR.Internal.VariableExpression)this.Green).VariableInfo;

        internal override global::SimpleCompiler.IR.IrNode? GetNodeSlot(int index) =>
                null;

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.IR.IrVisitor visitor) =>
            visitor.VisitVariableExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.IR.IrVisitor<TResult> visitor) =>
            visitor.VisitVariableExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitVariableExpression(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitVariableExpression(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitVariableExpression(this, arg1, arg2, arg3);

        public global::SimpleCompiler.IR.VariableExpression Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.IR.ResultKind resultKind,
            global::SimpleCompiler.IR.VariableInfo variableInfo
        )
        {
            if (
                this.OriginalNode != originalNode
                || this.ResultKind != resultKind
                || this.VariableInfo != variableInfo
            )
            {
                return global::SimpleCompiler.IR.IrFactory.VariableExpression(
                    originalNode,
                    resultKind,
                    variableInfo
                );
            }

            return this;
        }

        public global::SimpleCompiler.IR.VariableExpression WithOriginalNode(global::Loretta.CodeAnalysis.SyntaxReference? originalNode) =>
            this.Update(
                originalNode,
                this.ResultKind,
                this.VariableInfo
            );
        public global::SimpleCompiler.IR.VariableExpression WithResultKind(global::SimpleCompiler.IR.ResultKind resultKind) =>
            this.Update(
                this.OriginalNode,
                resultKind,
                this.VariableInfo
            );
        public global::SimpleCompiler.IR.VariableExpression WithVariableInfo(global::SimpleCompiler.IR.VariableInfo variableInfo) =>
            this.Update(
                this.OriginalNode,
                this.ResultKind,
                variableInfo
            );
    }
    public partial class UnaryOperationExpression : global::SimpleCompiler.IR.Expression
    {
        private global::SimpleCompiler.IR.Expression? _operand;

        internal UnaryOperationExpression(global::SimpleCompiler.IR.Internal.IrNode green, global::SimpleCompiler.IR.IrNode? parent)
            : base(green, parent)
        {
        }

        public override  global::Loretta.CodeAnalysis.SyntaxReference? OriginalNode => ((global::SimpleCompiler.IR.Internal.UnaryOperationExpression)this.Green).OriginalNode;
        public override  global::SimpleCompiler.IR.ResultKind ResultKind => ((global::SimpleCompiler.IR.Internal.UnaryOperationExpression)this.Green).ResultKind;
        public  global::SimpleCompiler.IR.UnaryOperationKind UnaryOperationKind => ((global::SimpleCompiler.IR.Internal.UnaryOperationExpression)this.Green).UnaryOperationKind;
        public global::SimpleCompiler.IR.Expression Operand => GetRed(ref this._operand, 0)!;

        internal override global::SimpleCompiler.IR.IrNode? GetNodeSlot(int index) =>
                index == 0 ? GetRed(ref this._operand, 0)! : null;

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.IR.IrVisitor visitor) =>
            visitor.VisitUnaryOperationExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.IR.IrVisitor<TResult> visitor) =>
            visitor.VisitUnaryOperationExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitUnaryOperationExpression(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitUnaryOperationExpression(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitUnaryOperationExpression(this, arg1, arg2, arg3);

        public global::SimpleCompiler.IR.UnaryOperationExpression Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.IR.ResultKind resultKind,
            global::SimpleCompiler.IR.UnaryOperationKind unaryOperationKind,
            global::SimpleCompiler.IR.Expression operand
        )
        {
            if (
                this.OriginalNode != originalNode
                || this.ResultKind != resultKind
                || this.UnaryOperationKind != unaryOperationKind
                || this.Operand != operand
            )
            {
                return global::SimpleCompiler.IR.IrFactory.UnaryOperationExpression(
                    originalNode,
                    resultKind,
                    unaryOperationKind,
                    operand
                );
            }

            return this;
        }

        public global::SimpleCompiler.IR.UnaryOperationExpression WithOriginalNode(global::Loretta.CodeAnalysis.SyntaxReference? originalNode) =>
            this.Update(
                originalNode,
                this.ResultKind,
                this.UnaryOperationKind,
                this.Operand
            );
        public global::SimpleCompiler.IR.UnaryOperationExpression WithResultKind(global::SimpleCompiler.IR.ResultKind resultKind) =>
            this.Update(
                this.OriginalNode,
                resultKind,
                this.UnaryOperationKind,
                this.Operand
            );
        public global::SimpleCompiler.IR.UnaryOperationExpression WithUnaryOperationKind(global::SimpleCompiler.IR.UnaryOperationKind unaryOperationKind) =>
            this.Update(
                this.OriginalNode,
                this.ResultKind,
                unaryOperationKind,
                this.Operand
            );
        public global::SimpleCompiler.IR.UnaryOperationExpression WithOperand(global::SimpleCompiler.IR.Expression operand) =>
            this.Update(
                this.OriginalNode,
                this.ResultKind,
                this.UnaryOperationKind,
                operand
            );
    }
    public partial class FunctionCallExpression : global::SimpleCompiler.IR.Expression
    {
        private global::SimpleCompiler.IR.Expression? _callee;
        private global::SimpleCompiler.IR.IrNode? _arguments;

        internal FunctionCallExpression(global::SimpleCompiler.IR.Internal.IrNode green, global::SimpleCompiler.IR.IrNode? parent)
            : base(green, parent)
        {
        }

        public override  global::Loretta.CodeAnalysis.SyntaxReference? OriginalNode => ((global::SimpleCompiler.IR.Internal.FunctionCallExpression)this.Green).OriginalNode;
        public override  global::SimpleCompiler.IR.ResultKind ResultKind => ((global::SimpleCompiler.IR.Internal.FunctionCallExpression)this.Green).ResultKind;
        public global::SimpleCompiler.IR.Expression Callee => GetRed(ref this._callee, 0)!;
            public global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Expression> Arguments => new global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Expression>(GetRed(ref this._arguments, 1));

        internal override global::SimpleCompiler.IR.IrNode? GetNodeSlot(int index) =>
                index switch
                {
                    0 => GetRed(ref this._callee, 0)!,
                    1 => GetRed(ref this._arguments, 1),
                    _ => null
                };

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.IR.IrVisitor visitor) =>
            visitor.VisitFunctionCallExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.IR.IrVisitor<TResult> visitor) =>
            visitor.VisitFunctionCallExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitFunctionCallExpression(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitFunctionCallExpression(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitFunctionCallExpression(this, arg1, arg2, arg3);

        public global::SimpleCompiler.IR.FunctionCallExpression Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.IR.ResultKind resultKind,
            global::SimpleCompiler.IR.Expression callee,
            global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Expression> arguments
        )
        {
            if (
                this.OriginalNode != originalNode
                || this.ResultKind != resultKind
                || this.Callee != callee
                || this.Arguments != arguments
            )
            {
                return global::SimpleCompiler.IR.IrFactory.FunctionCallExpression(
                    originalNode,
                    resultKind,
                    callee,
                    arguments
                );
            }

            return this;
        }

        public global::SimpleCompiler.IR.FunctionCallExpression WithOriginalNode(global::Loretta.CodeAnalysis.SyntaxReference? originalNode) =>
            this.Update(
                originalNode,
                this.ResultKind,
                this.Callee,
                this.Arguments
            );
        public global::SimpleCompiler.IR.FunctionCallExpression WithResultKind(global::SimpleCompiler.IR.ResultKind resultKind) =>
            this.Update(
                this.OriginalNode,
                resultKind,
                this.Callee,
                this.Arguments
            );
        public global::SimpleCompiler.IR.FunctionCallExpression WithCallee(global::SimpleCompiler.IR.Expression callee) =>
            this.Update(
                this.OriginalNode,
                this.ResultKind,
                callee,
                this.Arguments
            );
        public global::SimpleCompiler.IR.FunctionCallExpression WithArguments(global::SimpleCompiler.IR.IrList<global::SimpleCompiler.IR.Expression> arguments) =>
            this.Update(
                this.OriginalNode,
                this.ResultKind,
                this.Callee,
                arguments
            );
    }
    public partial class DiscardExpression : global::SimpleCompiler.IR.Expression
    {

        internal DiscardExpression(global::SimpleCompiler.IR.Internal.IrNode green, global::SimpleCompiler.IR.IrNode? parent)
            : base(green, parent)
        {
        }

        public override  global::Loretta.CodeAnalysis.SyntaxReference? OriginalNode => ((global::SimpleCompiler.IR.Internal.DiscardExpression)this.Green).OriginalNode;
        public override  global::SimpleCompiler.IR.ResultKind ResultKind => ((global::SimpleCompiler.IR.Internal.DiscardExpression)this.Green).ResultKind;

        internal override global::SimpleCompiler.IR.IrNode? GetNodeSlot(int index) =>
                null;

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.IR.IrVisitor visitor) =>
            visitor.VisitDiscardExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.IR.IrVisitor<TResult> visitor) =>
            visitor.VisitDiscardExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitDiscardExpression(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitDiscardExpression(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitDiscardExpression(this, arg1, arg2, arg3);

        public global::SimpleCompiler.IR.DiscardExpression Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.IR.ResultKind resultKind
        )
        {
            if (
                this.OriginalNode != originalNode
                || this.ResultKind != resultKind
            )
            {
                return global::SimpleCompiler.IR.IrFactory.DiscardExpression(
                    originalNode,
                    resultKind
                );
            }

            return this;
        }

        public global::SimpleCompiler.IR.DiscardExpression WithOriginalNode(global::Loretta.CodeAnalysis.SyntaxReference? originalNode) =>
            this.Update(
                originalNode,
                this.ResultKind
            );
        public global::SimpleCompiler.IR.DiscardExpression WithResultKind(global::SimpleCompiler.IR.ResultKind resultKind) =>
            this.Update(
                this.OriginalNode,
                resultKind
            );
    }
    public partial class ConstantExpression : global::SimpleCompiler.IR.Expression
    {

        internal ConstantExpression(global::SimpleCompiler.IR.Internal.IrNode green, global::SimpleCompiler.IR.IrNode? parent)
            : base(green, parent)
        {
        }

        public override  global::Loretta.CodeAnalysis.SyntaxReference? OriginalNode => ((global::SimpleCompiler.IR.Internal.ConstantExpression)this.Green).OriginalNode;
        public override  global::SimpleCompiler.IR.ResultKind ResultKind => ((global::SimpleCompiler.IR.Internal.ConstantExpression)this.Green).ResultKind;
        public  global::SimpleCompiler.IR.ConstantKind ConstantKind => ((global::SimpleCompiler.IR.Internal.ConstantExpression)this.Green).ConstantKind;
        public  object? Value => ((global::SimpleCompiler.IR.Internal.ConstantExpression)this.Green).Value;

        internal override global::SimpleCompiler.IR.IrNode? GetNodeSlot(int index) =>
                null;

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.IR.IrVisitor visitor) =>
            visitor.VisitConstantExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.IR.IrVisitor<TResult> visitor) =>
            visitor.VisitConstantExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitConstantExpression(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitConstantExpression(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitConstantExpression(this, arg1, arg2, arg3);

        public global::SimpleCompiler.IR.ConstantExpression Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.IR.ResultKind resultKind,
            global::SimpleCompiler.IR.ConstantKind constantKind,
            object? value
        )
        {
            if (
                this.OriginalNode != originalNode
                || this.ResultKind != resultKind
                || this.ConstantKind != constantKind
                || this.Value != value
            )
            {
                return global::SimpleCompiler.IR.IrFactory.ConstantExpression(
                    originalNode,
                    resultKind,
                    constantKind,
                    value
                );
            }

            return this;
        }

        public global::SimpleCompiler.IR.ConstantExpression WithOriginalNode(global::Loretta.CodeAnalysis.SyntaxReference? originalNode) =>
            this.Update(
                originalNode,
                this.ResultKind,
                this.ConstantKind,
                this.Value
            );
        public global::SimpleCompiler.IR.ConstantExpression WithResultKind(global::SimpleCompiler.IR.ResultKind resultKind) =>
            this.Update(
                this.OriginalNode,
                resultKind,
                this.ConstantKind,
                this.Value
            );
        public global::SimpleCompiler.IR.ConstantExpression WithConstantKind(global::SimpleCompiler.IR.ConstantKind constantKind) =>
            this.Update(
                this.OriginalNode,
                this.ResultKind,
                constantKind,
                this.Value
            );
        public global::SimpleCompiler.IR.ConstantExpression WithValue(object? value) =>
            this.Update(
                this.OriginalNode,
                this.ResultKind,
                this.ConstantKind,
                value
            );
    }
    public partial class BinaryOperationExpression : global::SimpleCompiler.IR.Expression
    {
        private global::SimpleCompiler.IR.Expression? _left;
        private global::SimpleCompiler.IR.Expression? _right;

        internal BinaryOperationExpression(global::SimpleCompiler.IR.Internal.IrNode green, global::SimpleCompiler.IR.IrNode? parent)
            : base(green, parent)
        {
        }

        public override  global::Loretta.CodeAnalysis.SyntaxReference? OriginalNode => ((global::SimpleCompiler.IR.Internal.BinaryOperationExpression)this.Green).OriginalNode;
        public override  global::SimpleCompiler.IR.ResultKind ResultKind => ((global::SimpleCompiler.IR.Internal.BinaryOperationExpression)this.Green).ResultKind;
        public  global::SimpleCompiler.IR.BinaryOperationKind BinaryOperationKind => ((global::SimpleCompiler.IR.Internal.BinaryOperationExpression)this.Green).BinaryOperationKind;
        public global::SimpleCompiler.IR.Expression Left => GetRed(ref this._left, 0)!;
        public global::SimpleCompiler.IR.Expression Right => GetRed(ref this._right, 1)!;

        internal override global::SimpleCompiler.IR.IrNode? GetNodeSlot(int index) =>
                index switch
                {
                    0 => GetRed(ref this._left, 0)!,
                    1 => GetRed(ref this._right, 1)!,
                    _ => null
                };

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.IR.IrVisitor visitor) =>
            visitor.VisitBinaryOperationExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.IR.IrVisitor<TResult> visitor) =>
            visitor.VisitBinaryOperationExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitBinaryOperationExpression(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitBinaryOperationExpression(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitBinaryOperationExpression(this, arg1, arg2, arg3);

        public global::SimpleCompiler.IR.BinaryOperationExpression Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.IR.ResultKind resultKind,
            global::SimpleCompiler.IR.BinaryOperationKind binaryOperationKind,
            global::SimpleCompiler.IR.Expression left,
            global::SimpleCompiler.IR.Expression right
        )
        {
            if (
                this.OriginalNode != originalNode
                || this.ResultKind != resultKind
                || this.BinaryOperationKind != binaryOperationKind
                || this.Left != left
                || this.Right != right
            )
            {
                return global::SimpleCompiler.IR.IrFactory.BinaryOperationExpression(
                    originalNode,
                    resultKind,
                    binaryOperationKind,
                    left,
                    right
                );
            }

            return this;
        }

        public global::SimpleCompiler.IR.BinaryOperationExpression WithOriginalNode(global::Loretta.CodeAnalysis.SyntaxReference? originalNode) =>
            this.Update(
                originalNode,
                this.ResultKind,
                this.BinaryOperationKind,
                this.Left,
                this.Right
            );
        public global::SimpleCompiler.IR.BinaryOperationExpression WithResultKind(global::SimpleCompiler.IR.ResultKind resultKind) =>
            this.Update(
                this.OriginalNode,
                resultKind,
                this.BinaryOperationKind,
                this.Left,
                this.Right
            );
        public global::SimpleCompiler.IR.BinaryOperationExpression WithBinaryOperationKind(global::SimpleCompiler.IR.BinaryOperationKind binaryOperationKind) =>
            this.Update(
                this.OriginalNode,
                this.ResultKind,
                binaryOperationKind,
                this.Left,
                this.Right
            );
        public global::SimpleCompiler.IR.BinaryOperationExpression WithLeft(global::SimpleCompiler.IR.Expression left) =>
            this.Update(
                this.OriginalNode,
                this.ResultKind,
                this.BinaryOperationKind,
                left,
                this.Right
            );
        public global::SimpleCompiler.IR.BinaryOperationExpression WithRight(global::SimpleCompiler.IR.Expression right) =>
            this.Update(
                this.OriginalNode,
                this.ResultKind,
                this.BinaryOperationKind,
                this.Left,
                right
            );
    }
    public partial class IrNone : global::SimpleCompiler.IR.IrNode
    {

        internal IrNone(global::SimpleCompiler.IR.Internal.IrNode green, global::SimpleCompiler.IR.IrNode? parent)
            : base(green, parent)
        {
        }

        public override  global::Loretta.CodeAnalysis.SyntaxReference? OriginalNode => ((global::SimpleCompiler.IR.Internal.IrNone)this.Green).OriginalNode;

        internal override global::SimpleCompiler.IR.IrNode? GetNodeSlot(int index) =>
                null;

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.IR.IrVisitor visitor) =>
            visitor.VisitIrNone(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.IR.IrVisitor<TResult> visitor) =>
            visitor.VisitIrNone(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitIrNone(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitIrNone(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.IR.IrVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitIrNone(this, arg1, arg2, arg3);

        public global::SimpleCompiler.IR.IrNone Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode
        )
        {
            if (
                this.OriginalNode != originalNode
            )
            {
                return global::SimpleCompiler.IR.IrFactory.IrNone(
                    originalNode
                );
            }

            return this;
        }

        public global::SimpleCompiler.IR.IrNone WithOriginalNode(global::Loretta.CodeAnalysis.SyntaxReference? originalNode) =>
            this.Update(
                originalNode
            );
    }
}