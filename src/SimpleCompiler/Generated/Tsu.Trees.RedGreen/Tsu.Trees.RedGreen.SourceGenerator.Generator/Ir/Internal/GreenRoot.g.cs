// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// Modified by the Tsu (https://github.com/GGG-KILLER/Tsu) project for embedding into other projects.
// <auto-generated />

#nullable enable

namespace SimpleCompiler.IR.Internal
{
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;

    abstract partial class IrNode
    {
        public const global::SimpleCompiler.IR.IrKind ListKind = global::SimpleCompiler.IR.IrKind.List;

        protected readonly global::SimpleCompiler.IR.IrKind _kind;
        private byte _slotCount;

        protected IrNode(global::SimpleCompiler.IR.IrKind kind, global::Loretta.CodeAnalysis.SyntaxReference? originalNode)
        {
            this._kind = kind;
            this._originalNode = originalNode;
        }

        public global::SimpleCompiler.IR.IrKind Kind => this._kind;
        public global::Loretta.CodeAnalysis.SyntaxReference? OriginalNode => this._originalNode;

        public int SlotCount
        {
            get
            {
                int count = this._slotCount;
                if (count == byte.MaxValue)
                    count = this.GetSlotCount();
                return count;
            }
            protected set => _slotCount = (byte) value;
        }

        public bool IsList => this._kind == ListKind;

        public abstract global::SimpleCompiler.IR.Internal.IrNode? GetSlot(int index);

        public global::SimpleCompiler.IR.Internal.IrNode GetRequiredSlot(int index)
        {
            var node = this.GetSlot(index);
            Debug.Assert(node != null);
            return node!;
        }

        protected virtual int GetSlotCount() => _slotCount;

        public global::SimpleCompiler.IR.Internal.ChildIrList ChildNodes() =>
            new global::SimpleCompiler.IR.Internal.ChildIrList(this);

        public IEnumerable<global::SimpleCompiler.IR.Internal.IrNode> EnumerateDescendants()
        {
            yield return this;

            var stack = new Stack<global::SimpleCompiler.IR.Internal.ChildIrList.Enumerator>(24);
            stack.Push(ChildNodes().GetEnumerator());

            while (stack.Count > 0)
            {
                var en = stack.Pop();
                if (!en.MoveNext())
                {
                    // no more down this branch
                    continue;
                }

                var current = en.Current;
                stack.Push(en); // put it back on stack (struct enumerator)

                yield return current;

                stack.Push(current.ChildNodes().GetEnumerator());
                continue;
            }
        }

        public virtual bool IsEquivalentTo([NotNullWhen(true)] global::SimpleCompiler.IR.Internal.IrNode? other)
        {
            if (this == other) return true;
            if (other == null) return false;
            if (this.Kind != other.Kind) return false;
            if (this.OriginalNode != other.OriginalNode) return false;

            var n = this.SlotCount;
            if (n != other.SlotCount) return false;

            for (int i = 0; i < n; i++)
            {
                var thisChild = this.GetSlot(i);
                var otherChild = other.GetSlot(i);
                if (thisChild != null && otherChild != null && !thisChild.IsEquivalentTo(otherChild))
                {
                    return false;
                }
            }

            return true;
        }

        /*
         * There are 3 overloads of this, because most callers already know what they have is a List<T> and only transform it.
         * In those cases List<TFrom> performs much better.
         * In other cases, the type is unknown / is IEnumerable<T>, where we try to find the best match.
         * There is another overload for IReadOnlyList, since most collections already implement this, so checking for it will
         * perform better then copying to a List<T>, though not as good as List<T> directly.
         */
        public static global::SimpleCompiler.IR.Internal.IrNode? CreateList<TFrom>(IEnumerable<TFrom>? enumerable, Func<TFrom, global::SimpleCompiler.IR.Internal.IrNode> select)
            => enumerable switch
            {
                null => null,
                List<TFrom> l => CreateList(l, select),
                IReadOnlyList<TFrom> l => CreateList(l, select),
                _ => CreateList(enumerable.ToList(), select)
            };

        public static global::SimpleCompiler.IR.Internal.IrNode? CreateList<TFrom>(List<TFrom> list, Func<TFrom, global::SimpleCompiler.IR.Internal.IrNode> select)
        {
            switch (list.Count)
            {
                case 0:
                    return null;
                case 1:
                    return select(list[0]);
                case 2:
                    return global::SimpleCompiler.IR.Internal.IrList.List(select(list[0]), select(list[1]));
                case 3:
                    return global::SimpleCompiler.IR.Internal.IrList.List(select(list[0]), select(list[1]), select(list[2]));
                default:
                {
                    var array = new global::SimpleCompiler.IR.Internal.IrNode[list.Count];
                    for (int i = 0; i < array.Length; i++)
                        array[i] = select(list[i]);
                    return global::SimpleCompiler.IR.Internal.IrList.List(array);
                }
            }
        }

        public static global::SimpleCompiler.IR.Internal.IrNode? CreateList<TFrom>(IReadOnlyList<TFrom> list, Func<TFrom, global::SimpleCompiler.IR.Internal.IrNode> select)
        {
            switch (list.Count)
            {
                case 0:
                    return null;
                case 1:
                    return select(list[0]);
                case 2:
                    return IrList.List(select(list[0]), select(list[1]));
                case 3:
                    return IrList.List(select(list[0]), select(list[1]), select(list[2]));
                default:
                {
                    var array = new global::SimpleCompiler.IR.Internal.IrNode[list.Count];
                    for (int i = 0; i < array.Length; i++)
                        array[i] = select(list[i]);
                    return IrList.List(array);
                }
            }
        }

        public global::SimpleCompiler.IR.IrNode CreateRed() => this.CreateRed(null);
        public abstract global::SimpleCompiler.IR.IrNode CreateRed(global::SimpleCompiler.IR.IrNode? parent);

        public abstract void Accept(global::SimpleCompiler.IR.Internal.IrVisitor visitor);
        public abstract TResult? Accept<TResult>(global::SimpleCompiler.IR.Internal.IrVisitor<TResult> visitor);
        public abstract TResult? Accept<T1, TResult>(global::SimpleCompiler.IR.Internal.IrVisitor<T1, TResult> visitor, T1 arg1);
        public abstract TResult? Accept<T1, T2, TResult>(global::SimpleCompiler.IR.Internal.IrVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2);
        public abstract TResult? Accept<T1, T2, T3, TResult>(global::SimpleCompiler.IR.Internal.IrVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3);
    }
}