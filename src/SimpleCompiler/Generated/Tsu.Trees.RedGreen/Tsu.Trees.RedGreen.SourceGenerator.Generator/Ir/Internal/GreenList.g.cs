// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// Modified by the Tsu (https://github.com/GGG-KILLER/Tsu) project for embedding into other projects.
// <auto-generated />

#nullable enable

namespace SimpleCompiler.IR.Internal
{
    internal abstract partial class IrList : global::SimpleCompiler.IR.Internal.IrNode
    {
        internal IrList()
            : base(ListKind, default(global::Loretta.CodeAnalysis.SyntaxReference)!)
        {
        }

        internal static global::SimpleCompiler.IR.Internal.IrNode List(global::SimpleCompiler.IR.Internal.IrNode child) => child;

        internal static WithTwoChildren List(global::SimpleCompiler.IR.Internal.IrNode child0, global::SimpleCompiler.IR.Internal.IrNode child1)
        {
            global::System.Diagnostics.Debug.Assert(child0 != null);
            global::System.Diagnostics.Debug.Assert(child1 != null);

            return new WithTwoChildren(child0, child1);
        }

        internal static WithThreeChildren List(global::SimpleCompiler.IR.Internal.IrNode child0, global::SimpleCompiler.IR.Internal.IrNode child1, global::SimpleCompiler.IR.Internal.IrNode child2)
        {
            global::System.Diagnostics.Debug.Assert(child0 != null);
            global::System.Diagnostics.Debug.Assert(child1 != null);
            global::System.Diagnostics.Debug.Assert(child2 != null);

            return new WithThreeChildren(child0, child1, child2);
        }

        internal static IrList List(global::SimpleCompiler.IR.Internal.IrNode[] children)
        {
            return new WithManyChildren(children);
        }

        internal abstract void CopyTo(global::SimpleCompiler.IR.Internal.IrNode[] array, int offset);

        internal static global::SimpleCompiler.IR.Internal.IrNode? Concat(global::SimpleCompiler.IR.Internal.IrNode? left, global::SimpleCompiler.IR.Internal.IrNode? right)
        {
            if (left == null)
            {
                return right;
            }

            if (right == null)
            {
                return left;
            }

            var rightList = right as IrList;
            if (left is IrList leftList)
            {
                if (rightList != null)
                {
                    var tmp = new global::SimpleCompiler.IR.Internal.IrNode[left.SlotCount + right.SlotCount];
                    leftList.CopyTo(tmp, 0);
                    rightList.CopyTo(tmp, left.SlotCount);
                    return List(tmp);
                }
                else
                {
                    var tmp = new global::SimpleCompiler.IR.Internal.IrNode[left.SlotCount + 1];
                    leftList.CopyTo(tmp, 0);
                    tmp[left.SlotCount] = right;
                    return List(tmp);
                }
            }
            else if (rightList != null)
            {
                var tmp = new global::SimpleCompiler.IR.Internal.IrNode[rightList.SlotCount + 1];
                tmp[0] = left;
                rightList.CopyTo(tmp, 1);
                return List(tmp);
            }
            else
            {
                return List(left, right);
            }
        }

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.IR.Internal.IrVisitor visitor) =>
            throw new global::System.InvalidOperationException("A list must not be visited directly.");

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.IR.Internal.IrVisitor<TResult> visitor) =>
            throw new global::System.InvalidOperationException("A list must not be visited directly.");

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.IR.Internal.IrVisitor<T1, TResult> visitor, T1 arg1) =>
            throw new global::System.InvalidOperationException("A list must not be visited directly.");

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.IR.Internal.IrVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            throw new global::System.InvalidOperationException("A list must not be visited directly.");

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.IR.Internal.IrVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            throw new global::System.InvalidOperationException("A list must not be visited directly.");
    }
}
