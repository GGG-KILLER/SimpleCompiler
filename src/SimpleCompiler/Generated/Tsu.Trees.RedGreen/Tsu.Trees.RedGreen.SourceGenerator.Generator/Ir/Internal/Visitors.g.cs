// <auto-generated />

#nullable enable

using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace SimpleCompiler.IR.Internal
{

    internal static partial class IrFactory
    {
        public static global::SimpleCompiler.IR.Internal.IrNone IrNone()
        {
#if DEBUG
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.IrNone(global::SimpleCompiler.IR.IrKind.None, default);
        }

        public static global::SimpleCompiler.IR.Internal.IrNone IrNone(global::Loretta.CodeAnalysis.SyntaxReference? originalNode)
        {
#if DEBUG
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.IrNone(global::SimpleCompiler.IR.IrKind.None, originalNode);
        }

        public static global::SimpleCompiler.IR.Internal.BinaryOperationExpression BinaryOperationExpression(global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.BinaryOperationKind binaryOperationKind, global::SimpleCompiler.IR.Internal.Expression left, global::SimpleCompiler.IR.Internal.Expression right)
        {
#if DEBUG
            if (left == null) throw new global::System.ArgumentNullException(nameof(left));
            if (right == null) throw new global::System.ArgumentNullException(nameof(right));
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.BinaryOperationExpression(global::SimpleCompiler.IR.IrKind.BinaryOperationExpression, default, resultKind, binaryOperationKind, left, right);
        }

        public static global::SimpleCompiler.IR.Internal.BinaryOperationExpression BinaryOperationExpression(global::Loretta.CodeAnalysis.SyntaxReference? originalNode, global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.BinaryOperationKind binaryOperationKind, global::SimpleCompiler.IR.Internal.Expression left, global::SimpleCompiler.IR.Internal.Expression right)
        {
#if DEBUG
            if (left == null) throw new global::System.ArgumentNullException(nameof(left));
            if (right == null) throw new global::System.ArgumentNullException(nameof(right));
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.BinaryOperationExpression(global::SimpleCompiler.IR.IrKind.BinaryOperationExpression, originalNode, resultKind, binaryOperationKind, left, right);
        }

        public static global::SimpleCompiler.IR.Internal.ConstantExpression ConstantExpression(global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.ConstantKind constantKind)
        {
#if DEBUG
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.ConstantExpression(global::SimpleCompiler.IR.IrKind.ConstantExpression, default, resultKind, constantKind, default);
        }

        public static global::SimpleCompiler.IR.Internal.ConstantExpression ConstantExpression(global::Loretta.CodeAnalysis.SyntaxReference? originalNode, global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.ConstantKind constantKind, object? value)
        {
#if DEBUG
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.ConstantExpression(global::SimpleCompiler.IR.IrKind.ConstantExpression, originalNode, resultKind, constantKind, value);
        }

        public static global::SimpleCompiler.IR.Internal.DiscardExpression DiscardExpression(global::SimpleCompiler.IR.ResultKind resultKind)
        {
#if DEBUG
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.DiscardExpression(global::SimpleCompiler.IR.IrKind.DiscardExpression, default, resultKind);
        }

        public static global::SimpleCompiler.IR.Internal.DiscardExpression DiscardExpression(global::Loretta.CodeAnalysis.SyntaxReference? originalNode, global::SimpleCompiler.IR.ResultKind resultKind)
        {
#if DEBUG
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.DiscardExpression(global::SimpleCompiler.IR.IrKind.DiscardExpression, originalNode, resultKind);
        }

        public static global::SimpleCompiler.IR.Internal.FunctionCallExpression FunctionCallExpression(global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.Internal.Expression callee)
        {
#if DEBUG
            if (callee == null) throw new global::System.ArgumentNullException(nameof(callee));
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.FunctionCallExpression(global::SimpleCompiler.IR.IrKind.FunctionCallExpression, default, resultKind, callee, default);
        }

        public static global::SimpleCompiler.IR.Internal.FunctionCallExpression FunctionCallExpression(global::Loretta.CodeAnalysis.SyntaxReference? originalNode, global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.Internal.Expression callee, global::SimpleCompiler.IR.Internal.IrList<global::SimpleCompiler.IR.Internal.Expression> arguments)
        {
#if DEBUG
            if (callee == null) throw new global::System.ArgumentNullException(nameof(callee));
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.FunctionCallExpression(global::SimpleCompiler.IR.IrKind.FunctionCallExpression, originalNode, resultKind, callee, arguments.Node);
        }

        public static global::SimpleCompiler.IR.Internal.UnaryOperationExpression UnaryOperationExpression(global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.UnaryOperationKind unaryOperationKind, global::SimpleCompiler.IR.Internal.Expression operand)
        {
#if DEBUG
            if (operand == null) throw new global::System.ArgumentNullException(nameof(operand));
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.UnaryOperationExpression(global::SimpleCompiler.IR.IrKind.UnaryOperationExpression, default, resultKind, unaryOperationKind, operand);
        }

        public static global::SimpleCompiler.IR.Internal.UnaryOperationExpression UnaryOperationExpression(global::Loretta.CodeAnalysis.SyntaxReference? originalNode, global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.UnaryOperationKind unaryOperationKind, global::SimpleCompiler.IR.Internal.Expression operand)
        {
#if DEBUG
            if (operand == null) throw new global::System.ArgumentNullException(nameof(operand));
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.UnaryOperationExpression(global::SimpleCompiler.IR.IrKind.UnaryOperationExpression, originalNode, resultKind, unaryOperationKind, operand);
        }

        public static global::SimpleCompiler.IR.Internal.VariableExpression VariableExpression(global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.VariableInfo variableInfo)
        {
#if DEBUG
            if (variableInfo == null) throw new global::System.ArgumentNullException(nameof(variableInfo));
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.VariableExpression(global::SimpleCompiler.IR.IrKind.VariableExpression, default, resultKind, variableInfo);
        }

        public static global::SimpleCompiler.IR.Internal.VariableExpression VariableExpression(global::Loretta.CodeAnalysis.SyntaxReference? originalNode, global::SimpleCompiler.IR.ResultKind resultKind, global::SimpleCompiler.IR.VariableInfo variableInfo)
        {
#if DEBUG
            if (variableInfo == null) throw new global::System.ArgumentNullException(nameof(variableInfo));
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.VariableExpression(global::SimpleCompiler.IR.IrKind.VariableExpression, originalNode, resultKind, variableInfo);
        }

        public static global::SimpleCompiler.IR.Internal.AssignmentStatement AssignmentStatement()
        {
#if DEBUG
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.AssignmentStatement(global::SimpleCompiler.IR.IrKind.AssignmentStatement, default, default, default);
        }

        public static global::SimpleCompiler.IR.Internal.AssignmentStatement AssignmentStatement(global::Loretta.CodeAnalysis.SyntaxReference? originalNode, global::SimpleCompiler.IR.Internal.IrList<global::SimpleCompiler.IR.Internal.Expression> assignees, global::SimpleCompiler.IR.Internal.IrList<global::SimpleCompiler.IR.Internal.Expression> values)
        {
#if DEBUG
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.AssignmentStatement(global::SimpleCompiler.IR.IrKind.AssignmentStatement, originalNode, assignees.Node, values.Node);
        }

        public static global::SimpleCompiler.IR.Internal.EmptyStatement EmptyStatement()
        {
#if DEBUG
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.EmptyStatement(global::SimpleCompiler.IR.IrKind.EmptyStatement, default);
        }

        public static global::SimpleCompiler.IR.Internal.EmptyStatement EmptyStatement(global::Loretta.CodeAnalysis.SyntaxReference? originalNode)
        {
#if DEBUG
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.EmptyStatement(global::SimpleCompiler.IR.IrKind.EmptyStatement, originalNode);
        }

        public static global::SimpleCompiler.IR.Internal.ExpressionStatement ExpressionStatement(global::SimpleCompiler.IR.Internal.Expression expression)
        {
#if DEBUG
            if (expression == null) throw new global::System.ArgumentNullException(nameof(expression));
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.ExpressionStatement(global::SimpleCompiler.IR.IrKind.ExpressionStatement, default, expression);
        }

        public static global::SimpleCompiler.IR.Internal.ExpressionStatement ExpressionStatement(global::Loretta.CodeAnalysis.SyntaxReference? originalNode, global::SimpleCompiler.IR.Internal.Expression expression)
        {
#if DEBUG
            if (expression == null) throw new global::System.ArgumentNullException(nameof(expression));
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.ExpressionStatement(global::SimpleCompiler.IR.IrKind.ExpressionStatement, originalNode, expression);
        }

        public static global::SimpleCompiler.IR.Internal.StatementList StatementList()
        {
#if DEBUG
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.StatementList(global::SimpleCompiler.IR.IrKind.StatementList, default, default, default);
        }

        public static global::SimpleCompiler.IR.Internal.StatementList StatementList(global::Loretta.CodeAnalysis.SyntaxReference? originalNode, global::SimpleCompiler.IR.Internal.IrList<global::SimpleCompiler.IR.Internal.Statement> statements, global::SimpleCompiler.IR.ScopeInfo? scopeInfo)
        {
#if DEBUG
#endif // DEBUG

            return new global::SimpleCompiler.IR.Internal.StatementList(global::SimpleCompiler.IR.IrKind.StatementList, originalNode, statements.Node, scopeInfo);
        }
    }


    internal partial class IrVisitor
    {
        public virtual void Visit(global::SimpleCompiler.IR.Internal.IrNode? node)
        {
            if (node != null)
            {
                node.Accept(this);
            }
        }
        public virtual void VisitIrNone(global::SimpleCompiler.IR.Internal.IrNone node) => this.DefaultVisit(node);
        public virtual void VisitBinaryOperationExpression(global::SimpleCompiler.IR.Internal.BinaryOperationExpression node) => this.DefaultVisit(node);
        public virtual void VisitConstantExpression(global::SimpleCompiler.IR.Internal.ConstantExpression node) => this.DefaultVisit(node);
        public virtual void VisitDiscardExpression(global::SimpleCompiler.IR.Internal.DiscardExpression node) => this.DefaultVisit(node);
        public virtual void VisitFunctionCallExpression(global::SimpleCompiler.IR.Internal.FunctionCallExpression node) => this.DefaultVisit(node);
        public virtual void VisitUnaryOperationExpression(global::SimpleCompiler.IR.Internal.UnaryOperationExpression node) => this.DefaultVisit(node);
        public virtual void VisitVariableExpression(global::SimpleCompiler.IR.Internal.VariableExpression node) => this.DefaultVisit(node);
        public virtual void VisitAssignmentStatement(global::SimpleCompiler.IR.Internal.AssignmentStatement node) => this.DefaultVisit(node);
        public virtual void VisitEmptyStatement(global::SimpleCompiler.IR.Internal.EmptyStatement node) => this.DefaultVisit(node);
        public virtual void VisitExpressionStatement(global::SimpleCompiler.IR.Internal.ExpressionStatement node) => this.DefaultVisit(node);
        public virtual void VisitStatementList(global::SimpleCompiler.IR.Internal.StatementList node) => this.DefaultVisit(node);
        protected virtual void DefaultVisit(global::SimpleCompiler.IR.Internal.IrNode node) { }
    }

    internal partial class IrVisitor<TResult>
    {
        public virtual TResult? Visit(global::SimpleCompiler.IR.Internal.IrNode? node) => node == null ? default : node.Accept(this
        );
        public virtual TResult? VisitIrNone(global::SimpleCompiler.IR.Internal.IrNone node) => this.DefaultVisit(node);
        public virtual TResult? VisitBinaryOperationExpression(global::SimpleCompiler.IR.Internal.BinaryOperationExpression node) => this.DefaultVisit(node);
        public virtual TResult? VisitConstantExpression(global::SimpleCompiler.IR.Internal.ConstantExpression node) => this.DefaultVisit(node);
        public virtual TResult? VisitDiscardExpression(global::SimpleCompiler.IR.Internal.DiscardExpression node) => this.DefaultVisit(node);
        public virtual TResult? VisitFunctionCallExpression(global::SimpleCompiler.IR.Internal.FunctionCallExpression node) => this.DefaultVisit(node);
        public virtual TResult? VisitUnaryOperationExpression(global::SimpleCompiler.IR.Internal.UnaryOperationExpression node) => this.DefaultVisit(node);
        public virtual TResult? VisitVariableExpression(global::SimpleCompiler.IR.Internal.VariableExpression node) => this.DefaultVisit(node);
        public virtual TResult? VisitAssignmentStatement(global::SimpleCompiler.IR.Internal.AssignmentStatement node) => this.DefaultVisit(node);
        public virtual TResult? VisitEmptyStatement(global::SimpleCompiler.IR.Internal.EmptyStatement node) => this.DefaultVisit(node);
        public virtual TResult? VisitExpressionStatement(global::SimpleCompiler.IR.Internal.ExpressionStatement node) => this.DefaultVisit(node);
        public virtual TResult? VisitStatementList(global::SimpleCompiler.IR.Internal.StatementList node) => this.DefaultVisit(node);
        protected virtual TResult? DefaultVisit(global::SimpleCompiler.IR.Internal.IrNode node) => default;
    }

    internal partial class IrVisitor<T1, TResult>
    {
        public virtual TResult? Visit(global::SimpleCompiler.IR.Internal.IrNode? node, T1 arg1) => node == null ? default : node.Accept(this
        , arg1);
        public virtual TResult? VisitIrNone(global::SimpleCompiler.IR.Internal.IrNone node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitBinaryOperationExpression(global::SimpleCompiler.IR.Internal.BinaryOperationExpression node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitConstantExpression(global::SimpleCompiler.IR.Internal.ConstantExpression node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitDiscardExpression(global::SimpleCompiler.IR.Internal.DiscardExpression node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitFunctionCallExpression(global::SimpleCompiler.IR.Internal.FunctionCallExpression node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitUnaryOperationExpression(global::SimpleCompiler.IR.Internal.UnaryOperationExpression node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitVariableExpression(global::SimpleCompiler.IR.Internal.VariableExpression node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitAssignmentStatement(global::SimpleCompiler.IR.Internal.AssignmentStatement node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitEmptyStatement(global::SimpleCompiler.IR.Internal.EmptyStatement node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitExpressionStatement(global::SimpleCompiler.IR.Internal.ExpressionStatement node, T1 arg1) => this.DefaultVisit(node, arg1);
        public virtual TResult? VisitStatementList(global::SimpleCompiler.IR.Internal.StatementList node, T1 arg1) => this.DefaultVisit(node, arg1);
        protected virtual TResult? DefaultVisit(global::SimpleCompiler.IR.Internal.IrNode node, T1 arg1) => default;
    }

    internal partial class IrVisitor<T1, T2, TResult>
    {
        public virtual TResult? Visit(global::SimpleCompiler.IR.Internal.IrNode? node, T1 arg1, T2 arg2) => node == null ? default : node.Accept(this
        , arg1, arg2);
        public virtual TResult? VisitIrNone(global::SimpleCompiler.IR.Internal.IrNone node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitBinaryOperationExpression(global::SimpleCompiler.IR.Internal.BinaryOperationExpression node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitConstantExpression(global::SimpleCompiler.IR.Internal.ConstantExpression node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitDiscardExpression(global::SimpleCompiler.IR.Internal.DiscardExpression node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitFunctionCallExpression(global::SimpleCompiler.IR.Internal.FunctionCallExpression node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitUnaryOperationExpression(global::SimpleCompiler.IR.Internal.UnaryOperationExpression node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitVariableExpression(global::SimpleCompiler.IR.Internal.VariableExpression node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitAssignmentStatement(global::SimpleCompiler.IR.Internal.AssignmentStatement node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitEmptyStatement(global::SimpleCompiler.IR.Internal.EmptyStatement node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitExpressionStatement(global::SimpleCompiler.IR.Internal.ExpressionStatement node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        public virtual TResult? VisitStatementList(global::SimpleCompiler.IR.Internal.StatementList node, T1 arg1, T2 arg2) => this.DefaultVisit(node, arg1, arg2);
        protected virtual TResult? DefaultVisit(global::SimpleCompiler.IR.Internal.IrNode node, T1 arg1, T2 arg2) => default;
    }

    internal partial class IrVisitor<T1, T2, T3, TResult>
    {
        public virtual TResult? Visit(global::SimpleCompiler.IR.Internal.IrNode? node, T1 arg1, T2 arg2, T3 arg3) => node == null ? default : node.Accept(this
        , arg1, arg2, arg3);
        public virtual TResult? VisitIrNone(global::SimpleCompiler.IR.Internal.IrNone node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitBinaryOperationExpression(global::SimpleCompiler.IR.Internal.BinaryOperationExpression node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitConstantExpression(global::SimpleCompiler.IR.Internal.ConstantExpression node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitDiscardExpression(global::SimpleCompiler.IR.Internal.DiscardExpression node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitFunctionCallExpression(global::SimpleCompiler.IR.Internal.FunctionCallExpression node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitUnaryOperationExpression(global::SimpleCompiler.IR.Internal.UnaryOperationExpression node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitVariableExpression(global::SimpleCompiler.IR.Internal.VariableExpression node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitAssignmentStatement(global::SimpleCompiler.IR.Internal.AssignmentStatement node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitEmptyStatement(global::SimpleCompiler.IR.Internal.EmptyStatement node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitExpressionStatement(global::SimpleCompiler.IR.Internal.ExpressionStatement node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        public virtual TResult? VisitStatementList(global::SimpleCompiler.IR.Internal.StatementList node, T1 arg1, T2 arg2, T3 arg3) => this.DefaultVisit(node, arg1, arg2, arg3);
        protected virtual TResult? DefaultVisit(global::SimpleCompiler.IR.Internal.IrNode node, T1 arg1, T2 arg2, T3 arg3) => default;
    }


    internal partial class IrRewriter : global::SimpleCompiler.IR.Internal.IrVisitor<global::SimpleCompiler.IR.Internal.IrNode>
    {
        public global::SimpleCompiler.IR.Internal.IrList<TNode> VisitList<TNode>(global::SimpleCompiler.IR.Internal.IrList<TNode> list) where TNode : global::SimpleCompiler.IR.Internal.IrNode
        {
            global::SimpleCompiler.IR.Internal.IrListBuilder? alternate = null;
            for (int i = 0, n = list.Count; i < n; i++)
            {
                var item = list[i];
                var visited = Visit(item);
                if (item != visited && alternate == null)
                {
                    alternate = new global::SimpleCompiler.IR.Internal.IrListBuilder(n);
                    alternate.AddRange(list, 0, i);
                }

                if (alternate != null && visited != null && visited.Kind != global::SimpleCompiler.IR.IrKind.None)
                {
                    alternate.Add(visited);
                }
            }

            if (alternate != null)
            {
                return alternate.ToList();
            }

            return list;
        }

        public override global::SimpleCompiler.IR.Internal.IrNode VisitIrNone(global::SimpleCompiler.IR.Internal.IrNone node) =>
            node.Update(node.OriginalNode);
        public override global::SimpleCompiler.IR.Internal.IrNode VisitBinaryOperationExpression(global::SimpleCompiler.IR.Internal.BinaryOperationExpression node) =>
            node.Update(node.OriginalNode, node.ResultKind, node.BinaryOperationKind, (global::SimpleCompiler.IR.Internal.Expression?)Visit(node.Left) ?? throw new global::System.InvalidOperationException("Left cannot be null."), (global::SimpleCompiler.IR.Internal.Expression?)Visit(node.Right) ?? throw new global::System.InvalidOperationException("Right cannot be null."));
        public override global::SimpleCompiler.IR.Internal.IrNode VisitConstantExpression(global::SimpleCompiler.IR.Internal.ConstantExpression node) =>
            node.Update(node.OriginalNode, node.ResultKind, node.ConstantKind, node.Value);
        public override global::SimpleCompiler.IR.Internal.IrNode VisitDiscardExpression(global::SimpleCompiler.IR.Internal.DiscardExpression node) =>
            node.Update(node.OriginalNode, node.ResultKind);
        public override global::SimpleCompiler.IR.Internal.IrNode VisitFunctionCallExpression(global::SimpleCompiler.IR.Internal.FunctionCallExpression node) =>
            node.Update(node.OriginalNode, node.ResultKind, (global::SimpleCompiler.IR.Internal.Expression?)Visit(node.Callee) ?? throw new global::System.InvalidOperationException("Callee cannot be null."), VisitList(node.Arguments));
        public override global::SimpleCompiler.IR.Internal.IrNode VisitUnaryOperationExpression(global::SimpleCompiler.IR.Internal.UnaryOperationExpression node) =>
            node.Update(node.OriginalNode, node.ResultKind, node.UnaryOperationKind, (global::SimpleCompiler.IR.Internal.Expression?)Visit(node.Operand) ?? throw new global::System.InvalidOperationException("Operand cannot be null."));
        public override global::SimpleCompiler.IR.Internal.IrNode VisitVariableExpression(global::SimpleCompiler.IR.Internal.VariableExpression node) =>
            node.Update(node.OriginalNode, node.ResultKind, node.VariableInfo);
        public override global::SimpleCompiler.IR.Internal.IrNode VisitAssignmentStatement(global::SimpleCompiler.IR.Internal.AssignmentStatement node) =>
            node.Update(node.OriginalNode, VisitList(node.Assignees), VisitList(node.Values));
        public override global::SimpleCompiler.IR.Internal.IrNode VisitEmptyStatement(global::SimpleCompiler.IR.Internal.EmptyStatement node) =>
            node.Update(node.OriginalNode);
        public override global::SimpleCompiler.IR.Internal.IrNode VisitExpressionStatement(global::SimpleCompiler.IR.Internal.ExpressionStatement node) =>
            node.Update(node.OriginalNode, (global::SimpleCompiler.IR.Internal.Expression?)Visit(node.Expression) ?? throw new global::System.InvalidOperationException("Expression cannot be null."));
        public override global::SimpleCompiler.IR.Internal.IrNode VisitStatementList(global::SimpleCompiler.IR.Internal.StatementList node) =>
            node.Update(node.OriginalNode, VisitList(node.Statements), node.ScopeInfo);
    }
}

