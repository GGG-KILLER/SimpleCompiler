// <auto-generated />

#nullable enable

namespace SimpleCompiler.MIR.Internal
{
    partial class Statement : global::SimpleCompiler.MIR.Internal.MirNode
    {
        protected Statement(
            global::SimpleCompiler.MIR.MirKind kind,
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode
        )
            : base(kind, originalNode)
        {
        }







    }
    partial class StatementList : global::SimpleCompiler.MIR.Internal.Statement
    {
        internal StatementList(
            global::SimpleCompiler.MIR.MirKind kind,
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.MIR.Internal.MirNode? statements,
            global::SimpleCompiler.MIR.ScopeInfo? scopeInfo
        )
            : base(kind, originalNode)
        {
            this.SlotCount = 1;
            this._statements = statements;
            this._scopeInfo = scopeInfo;
        }

        public global::SimpleCompiler.MIR.Internal.MirList<global::SimpleCompiler.MIR.Internal.Statement> Statements => new global::SimpleCompiler.MIR.Internal.MirList<global::SimpleCompiler.MIR.Internal.Statement>(this._statements);
        public global::SimpleCompiler.MIR.ScopeInfo? ScopeInfo => this._scopeInfo;

        public override global::SimpleCompiler.MIR.Internal.MirNode? GetSlot(int index) =>
            index == 0 ? this._statements : null;

        public override global::SimpleCompiler.MIR.MirNode CreateRed(global::SimpleCompiler.MIR.MirNode? parent) =>
            new global::SimpleCompiler.MIR.StatementList(this, parent);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.MIR.Internal.MirVisitor visitor) =>
            visitor.VisitStatementList(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<TResult> visitor) =>
            visitor.VisitStatementList(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitStatementList(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitStatementList(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitStatementList(this, arg1, arg2, arg3);

        public global::SimpleCompiler.MIR.Internal.StatementList Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.MIR.Internal.MirList<global::SimpleCompiler.MIR.Internal.Statement> statements,
            global::SimpleCompiler.MIR.ScopeInfo? scopeInfo
        )
        {
            if (
                this.OriginalNode != originalNode
                || this.Statements != statements
                || this.ScopeInfo != scopeInfo
            )
            {
                return global::SimpleCompiler.MIR.Internal.MirFactory.StatementList(
                    originalNode,
                    statements,
                    scopeInfo
                );
            }

            return this;
        }
    }
    partial class ExpressionStatement : global::SimpleCompiler.MIR.Internal.Statement
    {
        internal ExpressionStatement(
            global::SimpleCompiler.MIR.MirKind kind,
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.MIR.Internal.Expression expression
        )
            : base(kind, originalNode)
        {
            this.SlotCount = 1;
            this._expression = expression;
        }

        public global::SimpleCompiler.MIR.Internal.Expression Expression => this._expression;

        public override global::SimpleCompiler.MIR.Internal.MirNode? GetSlot(int index) =>
            index == 0 ? this._expression : null;

        public override global::SimpleCompiler.MIR.MirNode CreateRed(global::SimpleCompiler.MIR.MirNode? parent) =>
            new global::SimpleCompiler.MIR.ExpressionStatement(this, parent);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.MIR.Internal.MirVisitor visitor) =>
            visitor.VisitExpressionStatement(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<TResult> visitor) =>
            visitor.VisitExpressionStatement(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitExpressionStatement(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitExpressionStatement(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitExpressionStatement(this, arg1, arg2, arg3);

        public global::SimpleCompiler.MIR.Internal.ExpressionStatement Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.MIR.Internal.Expression expression
        )
        {
            if (
                this.OriginalNode != originalNode
                || this.Expression != expression
            )
            {
                return global::SimpleCompiler.MIR.Internal.MirFactory.ExpressionStatement(
                    originalNode,
                    expression
                );
            }

            return this;
        }
    }
    partial class EmptyStatement : global::SimpleCompiler.MIR.Internal.Statement
    {
        internal EmptyStatement(
            global::SimpleCompiler.MIR.MirKind kind,
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode
        )
            : base(kind, originalNode)
        {
            this.SlotCount = 0;
        }


        public override global::SimpleCompiler.MIR.Internal.MirNode? GetSlot(int index) =>
            null;

        public override global::SimpleCompiler.MIR.MirNode CreateRed(global::SimpleCompiler.MIR.MirNode? parent) =>
            new global::SimpleCompiler.MIR.EmptyStatement(this, parent);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.MIR.Internal.MirVisitor visitor) =>
            visitor.VisitEmptyStatement(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<TResult> visitor) =>
            visitor.VisitEmptyStatement(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitEmptyStatement(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitEmptyStatement(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitEmptyStatement(this, arg1, arg2, arg3);

        public global::SimpleCompiler.MIR.Internal.EmptyStatement Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode
        )
        {
            if (
                this.OriginalNode != originalNode
            )
            {
                return global::SimpleCompiler.MIR.Internal.MirFactory.EmptyStatement(
                    originalNode
                );
            }

            return this;
        }
    }
    partial class AssignmentStatement : global::SimpleCompiler.MIR.Internal.Statement
    {
        internal AssignmentStatement(
            global::SimpleCompiler.MIR.MirKind kind,
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.MIR.Internal.MirNode? assignees,
            global::SimpleCompiler.MIR.Internal.MirNode? values
        )
            : base(kind, originalNode)
        {
            this.SlotCount = 2;
            this._assignees = assignees;
            this._values = values;
        }

        public global::SimpleCompiler.MIR.Internal.MirList<global::SimpleCompiler.MIR.Internal.Expression> Assignees => new global::SimpleCompiler.MIR.Internal.MirList<global::SimpleCompiler.MIR.Internal.Expression>(this._assignees);
        public global::SimpleCompiler.MIR.Internal.MirList<global::SimpleCompiler.MIR.Internal.Expression> Values => new global::SimpleCompiler.MIR.Internal.MirList<global::SimpleCompiler.MIR.Internal.Expression>(this._values);

        public override global::SimpleCompiler.MIR.Internal.MirNode? GetSlot(int index) =>
            index switch
            {
                0 => this._assignees,
                1 => this._values,
                _ => null
            };

        public override global::SimpleCompiler.MIR.MirNode CreateRed(global::SimpleCompiler.MIR.MirNode? parent) =>
            new global::SimpleCompiler.MIR.AssignmentStatement(this, parent);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.MIR.Internal.MirVisitor visitor) =>
            visitor.VisitAssignmentStatement(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<TResult> visitor) =>
            visitor.VisitAssignmentStatement(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitAssignmentStatement(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitAssignmentStatement(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitAssignmentStatement(this, arg1, arg2, arg3);

        public global::SimpleCompiler.MIR.Internal.AssignmentStatement Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.MIR.Internal.MirList<global::SimpleCompiler.MIR.Internal.Expression> assignees,
            global::SimpleCompiler.MIR.Internal.MirList<global::SimpleCompiler.MIR.Internal.Expression> values
        )
        {
            if (
                this.OriginalNode != originalNode
                || this.Assignees != assignees
                || this.Values != values
            )
            {
                return global::SimpleCompiler.MIR.Internal.MirFactory.AssignmentStatement(
                    originalNode,
                    assignees,
                    values
                );
            }

            return this;
        }
    }
    partial class Expression : global::SimpleCompiler.MIR.Internal.MirNode
    {
        protected Expression(
            global::SimpleCompiler.MIR.MirKind kind,
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.MIR.ResultKind resultKind
        )
            : base(kind, originalNode)
        {
            this._resultKind = resultKind;
        }

        public global::SimpleCompiler.MIR.ResultKind ResultKind => this._resultKind;






    }
    partial class VariableExpression : global::SimpleCompiler.MIR.Internal.Expression
    {
        internal VariableExpression(
            global::SimpleCompiler.MIR.MirKind kind,
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.MIR.ResultKind resultKind,
            global::SimpleCompiler.MIR.VariableInfo variableInfo
        )
            : base(kind, originalNode, resultKind)
        {
            this.SlotCount = 0;
            this._variableInfo = variableInfo;
        }

        public global::SimpleCompiler.MIR.VariableInfo VariableInfo => this._variableInfo;

        public override global::SimpleCompiler.MIR.Internal.MirNode? GetSlot(int index) =>
            null;

        public override global::SimpleCompiler.MIR.MirNode CreateRed(global::SimpleCompiler.MIR.MirNode? parent) =>
            new global::SimpleCompiler.MIR.VariableExpression(this, parent);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.MIR.Internal.MirVisitor visitor) =>
            visitor.VisitVariableExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<TResult> visitor) =>
            visitor.VisitVariableExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitVariableExpression(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitVariableExpression(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitVariableExpression(this, arg1, arg2, arg3);

        public global::SimpleCompiler.MIR.Internal.VariableExpression Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.MIR.ResultKind resultKind,
            global::SimpleCompiler.MIR.VariableInfo variableInfo
        )
        {
            if (
                this.OriginalNode != originalNode
                || this.ResultKind != resultKind
                || this.VariableInfo != variableInfo
            )
            {
                return global::SimpleCompiler.MIR.Internal.MirFactory.VariableExpression(
                    originalNode,
                    resultKind,
                    variableInfo
                );
            }

            return this;
        }
    }
    partial class UnaryOperationExpression : global::SimpleCompiler.MIR.Internal.Expression
    {
        internal UnaryOperationExpression(
            global::SimpleCompiler.MIR.MirKind kind,
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.MIR.ResultKind resultKind,
            global::SimpleCompiler.MIR.UnaryOperationKind unaryOperationKind,
            global::SimpleCompiler.MIR.Internal.Expression operand
        )
            : base(kind, originalNode, resultKind)
        {
            this.SlotCount = 1;
            this._unaryOperationKind = unaryOperationKind;
            this._operand = operand;
        }

        public global::SimpleCompiler.MIR.UnaryOperationKind UnaryOperationKind => this._unaryOperationKind;
        public global::SimpleCompiler.MIR.Internal.Expression Operand => this._operand;

        public override global::SimpleCompiler.MIR.Internal.MirNode? GetSlot(int index) =>
            index == 0 ? this._operand : null;

        public override global::SimpleCompiler.MIR.MirNode CreateRed(global::SimpleCompiler.MIR.MirNode? parent) =>
            new global::SimpleCompiler.MIR.UnaryOperationExpression(this, parent);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.MIR.Internal.MirVisitor visitor) =>
            visitor.VisitUnaryOperationExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<TResult> visitor) =>
            visitor.VisitUnaryOperationExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitUnaryOperationExpression(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitUnaryOperationExpression(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitUnaryOperationExpression(this, arg1, arg2, arg3);

        public global::SimpleCompiler.MIR.Internal.UnaryOperationExpression Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.MIR.ResultKind resultKind,
            global::SimpleCompiler.MIR.UnaryOperationKind unaryOperationKind,
            global::SimpleCompiler.MIR.Internal.Expression operand
        )
        {
            if (
                this.OriginalNode != originalNode
                || this.ResultKind != resultKind
                || this.UnaryOperationKind != unaryOperationKind
                || this.Operand != operand
            )
            {
                return global::SimpleCompiler.MIR.Internal.MirFactory.UnaryOperationExpression(
                    originalNode,
                    resultKind,
                    unaryOperationKind,
                    operand
                );
            }

            return this;
        }
    }
    partial class FunctionCallExpression : global::SimpleCompiler.MIR.Internal.Expression
    {
        internal FunctionCallExpression(
            global::SimpleCompiler.MIR.MirKind kind,
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.MIR.ResultKind resultKind,
            global::SimpleCompiler.MIR.Internal.Expression callee,
            global::SimpleCompiler.MIR.Internal.MirNode? arguments
        )
            : base(kind, originalNode, resultKind)
        {
            this.SlotCount = 2;
            this._callee = callee;
            this._arguments = arguments;
        }

        public global::SimpleCompiler.MIR.Internal.Expression Callee => this._callee;
        public global::SimpleCompiler.MIR.Internal.MirList<global::SimpleCompiler.MIR.Internal.Expression> Arguments => new global::SimpleCompiler.MIR.Internal.MirList<global::SimpleCompiler.MIR.Internal.Expression>(this._arguments);

        public override global::SimpleCompiler.MIR.Internal.MirNode? GetSlot(int index) =>
            index switch
            {
                0 => this._callee,
                1 => this._arguments,
                _ => null
            };

        public override global::SimpleCompiler.MIR.MirNode CreateRed(global::SimpleCompiler.MIR.MirNode? parent) =>
            new global::SimpleCompiler.MIR.FunctionCallExpression(this, parent);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.MIR.Internal.MirVisitor visitor) =>
            visitor.VisitFunctionCallExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<TResult> visitor) =>
            visitor.VisitFunctionCallExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitFunctionCallExpression(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitFunctionCallExpression(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitFunctionCallExpression(this, arg1, arg2, arg3);

        public global::SimpleCompiler.MIR.Internal.FunctionCallExpression Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.MIR.ResultKind resultKind,
            global::SimpleCompiler.MIR.Internal.Expression callee,
            global::SimpleCompiler.MIR.Internal.MirList<global::SimpleCompiler.MIR.Internal.Expression> arguments
        )
        {
            if (
                this.OriginalNode != originalNode
                || this.ResultKind != resultKind
                || this.Callee != callee
                || this.Arguments != arguments
            )
            {
                return global::SimpleCompiler.MIR.Internal.MirFactory.FunctionCallExpression(
                    originalNode,
                    resultKind,
                    callee,
                    arguments
                );
            }

            return this;
        }
    }
    partial class DiscardExpression : global::SimpleCompiler.MIR.Internal.Expression
    {
        internal DiscardExpression(
            global::SimpleCompiler.MIR.MirKind kind,
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.MIR.ResultKind resultKind
        )
            : base(kind, originalNode, resultKind)
        {
            this.SlotCount = 0;
        }


        public override global::SimpleCompiler.MIR.Internal.MirNode? GetSlot(int index) =>
            null;

        public override global::SimpleCompiler.MIR.MirNode CreateRed(global::SimpleCompiler.MIR.MirNode? parent) =>
            new global::SimpleCompiler.MIR.DiscardExpression(this, parent);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.MIR.Internal.MirVisitor visitor) =>
            visitor.VisitDiscardExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<TResult> visitor) =>
            visitor.VisitDiscardExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitDiscardExpression(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitDiscardExpression(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitDiscardExpression(this, arg1, arg2, arg3);

        public global::SimpleCompiler.MIR.Internal.DiscardExpression Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.MIR.ResultKind resultKind
        )
        {
            if (
                this.OriginalNode != originalNode
                || this.ResultKind != resultKind
            )
            {
                return global::SimpleCompiler.MIR.Internal.MirFactory.DiscardExpression(
                    originalNode,
                    resultKind
                );
            }

            return this;
        }
    }
    partial class ConstantExpression : global::SimpleCompiler.MIR.Internal.Expression
    {
        internal ConstantExpression(
            global::SimpleCompiler.MIR.MirKind kind,
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.MIR.ResultKind resultKind,
            global::SimpleCompiler.MIR.ConstantKind constantKind,
            object? value
        )
            : base(kind, originalNode, resultKind)
        {
            this.SlotCount = 0;
            this._constantKind = constantKind;
            this._value = value;
        }

        public global::SimpleCompiler.MIR.ConstantKind ConstantKind => this._constantKind;
        public object? Value => this._value;

        public override global::SimpleCompiler.MIR.Internal.MirNode? GetSlot(int index) =>
            null;

        public override global::SimpleCompiler.MIR.MirNode CreateRed(global::SimpleCompiler.MIR.MirNode? parent) =>
            new global::SimpleCompiler.MIR.ConstantExpression(this, parent);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.MIR.Internal.MirVisitor visitor) =>
            visitor.VisitConstantExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<TResult> visitor) =>
            visitor.VisitConstantExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitConstantExpression(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitConstantExpression(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitConstantExpression(this, arg1, arg2, arg3);

        public global::SimpleCompiler.MIR.Internal.ConstantExpression Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.MIR.ResultKind resultKind,
            global::SimpleCompiler.MIR.ConstantKind constantKind,
            object? value
        )
        {
            if (
                this.OriginalNode != originalNode
                || this.ResultKind != resultKind
                || this.ConstantKind != constantKind
                || this.Value != value
            )
            {
                return global::SimpleCompiler.MIR.Internal.MirFactory.ConstantExpression(
                    originalNode,
                    resultKind,
                    constantKind,
                    value
                );
            }

            return this;
        }
    }
    partial class BinaryOperationExpression : global::SimpleCompiler.MIR.Internal.Expression
    {
        internal BinaryOperationExpression(
            global::SimpleCompiler.MIR.MirKind kind,
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.MIR.ResultKind resultKind,
            global::SimpleCompiler.MIR.BinaryOperationKind binaryOperationKind,
            global::SimpleCompiler.MIR.Internal.Expression left,
            global::SimpleCompiler.MIR.Internal.Expression right
        )
            : base(kind, originalNode, resultKind)
        {
            this.SlotCount = 2;
            this._binaryOperationKind = binaryOperationKind;
            this._left = left;
            this._right = right;
        }

        public global::SimpleCompiler.MIR.BinaryOperationKind BinaryOperationKind => this._binaryOperationKind;
        public global::SimpleCompiler.MIR.Internal.Expression Left => this._left;
        public global::SimpleCompiler.MIR.Internal.Expression Right => this._right;

        public override global::SimpleCompiler.MIR.Internal.MirNode? GetSlot(int index) =>
            index switch
            {
                0 => this._left,
                1 => this._right,
                _ => null
            };

        public override global::SimpleCompiler.MIR.MirNode CreateRed(global::SimpleCompiler.MIR.MirNode? parent) =>
            new global::SimpleCompiler.MIR.BinaryOperationExpression(this, parent);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.MIR.Internal.MirVisitor visitor) =>
            visitor.VisitBinaryOperationExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<TResult> visitor) =>
            visitor.VisitBinaryOperationExpression(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitBinaryOperationExpression(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitBinaryOperationExpression(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitBinaryOperationExpression(this, arg1, arg2, arg3);

        public global::SimpleCompiler.MIR.Internal.BinaryOperationExpression Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode,
            global::SimpleCompiler.MIR.ResultKind resultKind,
            global::SimpleCompiler.MIR.BinaryOperationKind binaryOperationKind,
            global::SimpleCompiler.MIR.Internal.Expression left,
            global::SimpleCompiler.MIR.Internal.Expression right
        )
        {
            if (
                this.OriginalNode != originalNode
                || this.ResultKind != resultKind
                || this.BinaryOperationKind != binaryOperationKind
                || this.Left != left
                || this.Right != right
            )
            {
                return global::SimpleCompiler.MIR.Internal.MirFactory.BinaryOperationExpression(
                    originalNode,
                    resultKind,
                    binaryOperationKind,
                    left,
                    right
                );
            }

            return this;
        }
    }
    partial class MirNone : global::SimpleCompiler.MIR.Internal.MirNode
    {
        internal MirNone(
            global::SimpleCompiler.MIR.MirKind kind,
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode
        )
            : base(kind, originalNode)
        {
            this.SlotCount = 0;
        }


        public override global::SimpleCompiler.MIR.Internal.MirNode? GetSlot(int index) =>
            null;

        public override global::SimpleCompiler.MIR.MirNode CreateRed(global::SimpleCompiler.MIR.MirNode? parent) =>
            new global::SimpleCompiler.MIR.MirNone(this, parent);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override void Accept(global::SimpleCompiler.MIR.Internal.MirVisitor visitor) =>
            visitor.VisitMirNone(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<TResult> visitor) =>
            visitor.VisitMirNone(this);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, TResult> visitor, T1 arg1) =>
            visitor.VisitMirNone(this, arg1);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, TResult> visitor, T1 arg1, T2 arg2) =>
            visitor.VisitMirNone(this, arg1, arg2);

        [return: global::System.Diagnostics.CodeAnalysis.MaybeNull]
        public override TResult Accept<T1, T2, T3, TResult>(global::SimpleCompiler.MIR.Internal.MirVisitor<T1, T2, T3, TResult> visitor, T1 arg1, T2 arg2, T3 arg3) =>
            visitor.VisitMirNone(this, arg1, arg2, arg3);

        public global::SimpleCompiler.MIR.Internal.MirNone Update(
            global::Loretta.CodeAnalysis.SyntaxReference? originalNode
        )
        {
            if (
                this.OriginalNode != originalNode
            )
            {
                return global::SimpleCompiler.MIR.Internal.MirFactory.MirNone(
                    originalNode
                );
            }

            return this;
        }
    }
}